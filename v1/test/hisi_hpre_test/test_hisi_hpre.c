/*
 * Copyright 2019 Huawei Technologies Co.,Ltd.All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//#define DEBUG

#include <stdio.h>
#include <string.h>
#include <fcntl.h>
#define __USE_GNU
#include <sched.h>
#include <pthread.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/syscall.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <unistd.h>
#include <semaphore.h>

#include "test_hisi_hpre.h"
#include "../../wd.h"
#include "../../wd_rsa.h"
#include "../../wd_dh.h"
#include "../../wd_bmm.h"
#include "../../wd_util.h"

#define HPRE_TST_PRT		printf
#define BN_ULONG		unsigned long
#define RSA_NO_PADDING		3
#define HPRE_TST_MAX_Q		1
#define HPRE_PADDING_SZ		16
#define TEST_MAX_THRD		128
#define MAX_TRY_TIMES		10000
#define LOG_INTVL_NUM		8
#define WD_RSA_CTX_MSG_NUM		64
#define WD_DH_CTX_MSG_NUM		64
#define DH_GENERATOR_2			2
#define DH_GENERATOR_5			5
#define TEST_CNT		10

typedef unsigned int u32;

struct bignum_st {
	BN_ULONG *d;                /* Pointer to an array of 'BN_BITS2' bit
					 * chunks. */
	int top;                    /* Index of last used d +1. */
	/* The next are internal book keeping for bn_expand. */
	int dmax;                   /* Size of the d array. */
	int neg;                    /* one if the number is negative */
	int flags;
};

/* stub structures */
struct rsa_st {
	int xxx;
};

struct dh_st {
	int xxx;
};

struct bn_gencb_st {
	int xxx;
};

struct test_hpre_pthread_dt {
	int cpu_id;
	enum alg_op_type op_type;
	int thread_num;
	void *pool;
	void *q;
	struct timeval start_tval;
	u32 send_task_num;
	u32 recv_task_num;
};

/* stub definitions */
typedef struct rsa_st RSA;
typedef struct dh_st DH;
typedef struct bignum_st BIGNUM;
typedef struct bn_gencb_st BN_GENCB;

enum dh_check_index {
	DH_INVALID,
	DH_ALICE_PUBKEY,
	DH_BOB_PUBKEY,
	DH_ALICE_PRIVKEY
};

struct rsa_async_tag {
	void *ctx;
	int thread_id;
	int cnt;
	struct test_hpre_pthread_dt *thread_info;
};

struct dh_user_tag_info {
	u32 op;
	int pid;
	int thread_id;
	void *test_ctx;
	void *thread_data;
};

struct async_test_openssl_param {
	RSA *rsa;
	BIGNUM *p;
	BIGNUM *q;
	BIGNUM *e;
	BIGNUM *n;
	BIGNUM *d;
	BIGNUM *dp;
	BIGNUM *dq;
	BIGNUM *qinv;
	void *ssl_verify_result;
	void *ssl_sign_result;
	void *plantext;
	int size;
};

static int key_bits = 2048;
static int openssl_check;
static int only_soft;
static int performance_test = 1;
static int t_times = 10;
static int t_seconds = 0;
static int with_log;
static int is_system_test;
static int ctx_num_per_q = 1;
static int q_num = 1;
static char *g_mode = "-crt";
static volatile int asyn_thread_exit = 0;

static __thread RSA *hpre_test_rsa;
static pthread_t system_test_thrds[TEST_MAX_THRD];
static struct test_hpre_pthread_dt test_thrds_data[TEST_MAX_THRD];
static struct async_test_openssl_param ssl_params;

static char *rsa_op_str[WCRYPTO_RSA_GENKEY + 1] = {
		"invalid_op",
		"rsa_sign",
		"rsa_verify",
		"rsa_keygen",
};

static char *dh_op_str[WCRYPTO_DH_PHASE2] = {
		"ph1",
		"ph2"
};

static char *rsa_op_str_perf[WCRYPTO_RSA_GENKEY + 1] = {
		"invalid_op",
		"sign",
		"verify",
		"gen",
};

char dh_g_5[] = {0x05};
char dh_g_2[] = {0x02};

char dh_p_768[] = {
	0xdd, 0xe8, 0xa1, 0x7d, 0xdd, 0x39, 0x87, 0x3c, 0xa1, 0x6a, 0xeb, 0x1b, 0x4f, 0x14, 0x72, 0x88,
	0x6c, 0x14, 0x6d, 0x24, 0xb7, 0xda, 0xf8, 0x97, 0xaa, 0xba, 0xb4, 0xdd, 0xc9, 0x5b, 0x28, 0x10,
	0x49, 0xfa, 0x93, 0xcc, 0x62, 0xc0, 0x70, 0xf8, 0xd6, 0xdc, 0xb2, 0x80, 0x35, 0x20, 0x84, 0xa4,
	0x99, 0xfc, 0x10, 0x7c, 0x9d, 0xc0, 0xc6, 0xd4, 0x8b, 0x0c, 0x57, 0xf1, 0x01, 0xf5, 0x1a, 0x4f,
	0x20, 0xfa, 0x8d, 0x66, 0x8b, 0x22, 0x3c, 0x96, 0xef, 0xd0, 0xde, 0xe5, 0x7e, 0x7f, 0x23, 0xdc,
	0x6d, 0x71, 0xdf, 0xc3, 0xe5, 0x1b, 0x39, 0xfe, 0xb7, 0x77, 0xe5, 0x72, 0x0d, 0x1c, 0x8d, 0xb7
};

char dh_xa_768[] = {
	0xe0, 0x80, 0x86, 0x24, 0xe2, 0x20, 0x35, 0x97, 0xda, 0x0e, 0x68, 0x39, 0x01, 0xdd, 0x01, 0x87,
	0xa2, 0x47, 0xd2, 0x0d, 0xee, 0xfe, 0xdc, 0x5a, 0x37, 0x23, 0xeb, 0x3d, 0xe8, 0x1e, 0x39, 0x2d,
	0xbf, 0xa6, 0xe9, 0x17, 0x48, 0xe2, 0xea, 0xef, 0x1d, 0x2f, 0xe2, 0xaf, 0x3c, 0xbc, 0xae, 0xa7,
	0x42, 0x9b, 0xa5, 0x7d, 0x47, 0x8a, 0x20, 0xc5, 0xae, 0xa1, 0xe4, 0xe8, 0x1c, 0x05, 0xc0, 0x0a,
	0x05, 0xdc, 0x01, 0x74, 0xde, 0xad, 0xad, 0x07, 0xec, 0x6e, 0x6a, 0xc7, 0xee, 0x0f, 0xb8, 0xbe,
	0xaa, 0x46, 0x61, 0x8c, 0x12, 0x5a, 0xaf, 0x05, 0xff, 0x1b, 0x35, 0x6b, 0xe2, 0x3d, 0x48, 0x4f
};

char dh_xb_768[] = {
	0x8b, 0xd9, 0xf8, 0x14, 0xe6, 0x42, 0x95, 0xbd, 0x9a, 0x96, 0xbe, 0xf4, 0x7d, 0x26, 0x5d, 0xa1,
	0x81, 0x9b, 0x1c, 0xec, 0xfe, 0xce, 0x9,  0x1d, 0xb7, 0x7a, 0xba, 0xca, 0x7f, 0x54, 0xee, 0x36,
	0x54, 0x65, 0x4a, 0xd0, 0x5c, 0x84, 0x8c, 0x3e, 0x1b, 0xfe, 0x91, 0x6f, 0x95, 0xb5, 0x76, 0xbf,
	0x61, 0x2a, 0x7, 0x23, 0x86, 0xb9, 0xe0, 0x19, 0x29, 0xcf, 0xea, 0x3a, 0x1,  0xbf, 0xee, 0x1b,
	0x5e, 0x3c, 0x4, 0xff, 0x1d, 0xcf, 0xa6, 0x56, 0xb3, 0x22, 0xbb, 0x45, 0x4b, 0x7f, 0x83, 0x87,
	0xef, 0x21, 0x5, 0xf7, 0x38, 0x1f, 0x6,  0x4d, 0x71, 0x0b, 0xe3, 0xe1, 0xb7, 0x7e, 0xae, 0x18
};

char dh_except_a_pubkey_768[] = {
	0xba, 0xe7, 0x3,  0x5b, 0xe4, 0x70, 0x8b, 0xe0, 0xe1, 0x92, 0x13, 0x86, 0x74, 0x4,  0xdc, 0x6a,
	0x0a, 0x2a, 0x20, 0xec, 0x6d, 0xbf, 0xf0, 0x46, 0xf7, 0x9,  0x2,  0xdb, 0x2f, 0x70, 0x11, 0xdd,
	0xb0, 0x13, 0xa2, 0xc1, 0x58, 0x74, 0x29, 0x19, 0x8d, 0x4a, 0x94, 0x80, 0x0b, 0xd7, 0x25, 0x85,
	0x10, 0x35, 0x97, 0x48, 0x6e, 0x70, 0x28, 0xae, 0x58, 0x97, 0x7d, 0xf2, 0x19, 0x27, 0x13, 0xab,
	0x47, 0x9b, 0x54, 0xdf, 0xc3, 0x5b, 0x5f, 0x5e, 0xb4, 0x64, 0x47, 0xce, 0x40, 0x3b, 0x0c, 0x4a,
	0x62, 0x52, 0xba, 0xc7, 0xf0, 0x36, 0x87, 0x9c, 0x79, 0x9a, 0x83, 0x11, 0x61, 0x0c, 0x1b, 0x6b
};

char dh_except_b_pubkey_768[] = {
	0x0d, 0xe8, 0xa1, 0x7d, 0xdd, 0x39, 0x87, 0x3c, 0xa1, 0x6a, 0xeb, 0x1b, 0x4f, 0x14, 0x72, 0x88,
	0x6c, 0x14, 0x6d, 0x24, 0xb7, 0xda, 0xf8, 0x97, 0xaa, 0xba, 0xb4, 0xdd, 0xc9, 0x5b, 0x28, 0x10,
	0x49, 0xfa, 0x93, 0xcc, 0x62, 0xc0, 0x70, 0xf8, 0xd6, 0xdc, 0xb2, 0x80, 0x35, 0x20, 0x84, 0xa4,
	0x99, 0xfc, 0x10, 0x7c, 0x9d, 0xc0, 0xc6, 0xd4, 0x8b, 0x0c, 0x57, 0xf1, 0x1,  0xf5, 0x1a, 0x4f,
	0x20, 0xfa, 0x8d, 0x66, 0x8b, 0x22, 0x3c, 0x96, 0xef, 0xd0, 0xde, 0xe5, 0x7e, 0x7f, 0x23, 0xdc,
	0x6d, 0x71, 0xdf, 0xc3, 0xe5, 0x1b, 0x39, 0xfe, 0xb7, 0x77, 0xe5, 0x72, 0x0d, 0x1c, 0x8d, 0xb7
};

char dh_share_key_768[] = {
	0x55, 0x9,  0x6b, 0x9c, 0xc6, 0x37, 0xa9, 0x9b, 0xdf, 0x67, 0x73, 0x7b, 0x46, 0xf9, 0x63, 0x47,
	0xcb, 0xa0, 0x57, 0x2a, 0xed, 0x97, 0x2f, 0xfe, 0x92, 0xf2, 0x20, 0x2c, 0x7e, 0xee, 0x7d, 0x11,
	0x78, 0xe6, 0xb9, 0x9,  0xd1, 0x94, 0xce, 0xd1, 0x5b, 0xf4, 0x44, 0xa9, 0xcb, 0x26, 0x2,  0x36,
	0x57, 0x2c, 0xa2, 0xbe, 0x37, 0xde, 0x86, 0x46, 0x20, 0x27, 0x9d, 0xa0, 0x2f, 0x4,  0xc1, 0xcd,
	0xff, 0x81, 0xe5, 0xe6, 0x2c, 0x9e, 0x39, 0x82, 0x31, 0x54, 0x33, 0xf8, 0xe7, 0xa0, 0xe5, 0x96,
	0xa4, 0x40, 0xc4, 0x44, 0xfe, 0x93, 0x66, 0xe2, 0xda, 0xaa, 0xb8, 0xfb, 0x2f, 0x3b, 0x8c, 0xce,
};

char dh_p_1024[] = {
	0x6a, 0xf3, 0x2c, 0xd2, 0x2d, 0x55, 0xc1, 0x54, 0x40, 0x18, 0x71, 0x07, 0x96, 0xa9, 0x56, 0x6e,
	0x45, 0x58, 0x24, 0xce, 0x75, 0x80, 0x3,  0x68, 0x36, 0x96, 0x03, 0xb2, 0x9c, 0x25, 0xbc, 0x55,
	0x0d, 0xe8, 0xa1, 0x7d, 0xdd, 0x39, 0x87, 0x3c, 0xa1, 0x6a, 0xeb, 0x1b, 0x4f, 0x14, 0x72, 0x88,
	0x6c, 0x14, 0x6d, 0x24, 0xb7, 0xda, 0xf8, 0x97, 0xaa, 0xba, 0xb4, 0xdd, 0xc9, 0x5b, 0x28, 0x10,
	0x49, 0xfa, 0x93, 0xcc, 0x62, 0xc0, 0x70, 0xf8, 0xd6, 0xdc, 0xb2, 0x80, 0x35, 0x20, 0x84, 0xa4,
	0x99, 0xfc, 0x10, 0x7c, 0x9d, 0xc0, 0xc6, 0xd4, 0x8b, 0x0c, 0x57, 0xf1, 0x01, 0xf5, 0x1a, 0x4f,
	0x20, 0xfa, 0x8d, 0x66, 0x8b, 0x22, 0x3c, 0x96, 0xef, 0xd0, 0xde, 0xe5, 0x7e, 0x7f, 0x23, 0xdc,
	0x6d, 0x71, 0xdf, 0xc3, 0xe5, 0x1b, 0x39, 0xfe, 0xb7, 0x77, 0xe5, 0x72, 0x0d, 0x1c, 0x8d, 0xb7
};

char dh_xa_1024[] = {
	0x0f, 0x2a, 0x77, 0x25, 0x4b, 0xb3, 0xd3, 0x2d, 0xfd, 0x94, 0x8b, 0x53, 0x02, 0x21, 0x40, 0xd7,
	0x36, 0x76, 0xf3, 0xc8, 0xc0, 0x36, 0x3d, 0x23, 0xc9, 0xbd, 0x92, 0x51, 0xf2, 0x4b, 0x83, 0x15,
	0xe0, 0x80, 0x86, 0x24, 0xe2, 0x20, 0x35, 0x97, 0xda, 0x0e, 0x68, 0x39, 0x01, 0xdd, 0x01, 0x87,
	0xa2, 0x47, 0xd2, 0x0d, 0xee, 0xfe, 0xdc, 0x5a, 0x37, 0x23, 0xeb, 0x3d, 0xe8, 0x1e, 0x39, 0x2d,
	0xbf, 0xa6, 0xe9, 0x17, 0x48, 0xe2, 0xea, 0xef, 0x1d, 0x2f, 0xe2, 0xaf, 0x3c, 0xbc, 0xae, 0xa7,
	0x42, 0x9b, 0xa5, 0x7d, 0x47, 0x8a, 0x20, 0xc5, 0xae, 0xa1, 0xe4, 0xe8, 0x1c, 0x05, 0xc0, 0x0a,
	0x05, 0xdc, 0x01, 0x74, 0xde, 0xad, 0xad, 0x07, 0xec, 0x6e, 0x6a, 0xc7, 0xee, 0x0f, 0xb8, 0xbe,
	0xaa, 0x46, 0x61, 0x8c, 0x12, 0x5a, 0xaf, 0x05, 0xff, 0x1b, 0x35, 0x6b, 0xe2, 0x3d, 0x48, 0x4f
};

char dh_xb_1024[] = {
	0x5e, 0x21, 0x0a, 0x9e, 0x3,  0xdd, 0x3f, 0xcc, 0x38, 0xf6, 0xa9, 0xa6, 0xf8, 0xfd, 0x15, 0x7d,
	0x67, 0x4e, 0x14, 0xae, 0x4d, 0xe2, 0x1f, 0x78, 0x77, 0xfb, 0x83, 0x5f, 0x48, 0xa8, 0xc8, 0x21,
	0x8b, 0xd9, 0xf8, 0x14, 0xe6, 0x42, 0x95, 0xbd, 0x9a, 0x96, 0xbe, 0xf4, 0x7d, 0x26, 0x5d, 0xa1,
	0x81, 0x9b, 0x1c, 0xec, 0xfe, 0xce, 0x9,  0x1d, 0xb7, 0x7a, 0xba, 0xca, 0x7f, 0x54, 0xee, 0x36,
	0x54, 0x65, 0x4a, 0xd0, 0x5c, 0x84, 0x8c, 0x3e, 0x1b, 0xfe, 0x91, 0x6f, 0x95, 0xb5, 0x76, 0xbf,
	0x61, 0x2a, 0x7, 0x23, 0x86, 0xb9, 0xe0, 0x19, 0x29, 0xcf, 0xea, 0x3a, 0x1,  0xbf, 0xee, 0x1b,
	0x5e, 0x3c, 0x4, 0xff, 0x1d, 0xcf, 0xa6, 0x56, 0xb3, 0x22, 0xbb, 0x45, 0x4b, 0x7f, 0x83, 0x87,
	0xef, 0x21, 0x5, 0xf7, 0x38, 0x1f, 0x6,  0x4d, 0x71, 0x0b, 0xe3, 0xe1, 0xb7, 0x7e, 0xae, 0x18
};

char dh_except_a_pubkey_1024[] = {
	0x5d, 0xa6, 0x7,  0x56, 0x93, 0x89, 0xe5, 0x0f, 0x2a, 0xb5, 0x67, 0x3a, 0xcf, 0xc3, 0x82, 0x83,
	0xf6, 0x88, 0x52, 0x0b, 0xfc, 0x6a, 0x5b, 0x1a, 0x57, 0x87, 0x86, 0xef, 0xda, 0x47, 0xdb, 0x4d,
	0xba, 0xe7, 0x3,  0x5b, 0xe4, 0x70, 0x8b, 0xe0, 0xe1, 0x92, 0x13, 0x86, 0x74, 0x4,  0xdc, 0x6a,
	0x0a, 0x2a, 0x20, 0xec, 0x6d, 0xbf, 0xf0, 0x46, 0xf7, 0x9,  0x2,  0xdb, 0x2f, 0x70, 0x11, 0xdd,
	0xb0, 0x13, 0xa2, 0xc1, 0x58, 0x74, 0x29, 0x19, 0x8d, 0x4a, 0x94, 0x80, 0x0b, 0xd7, 0x25, 0x85,
	0x10, 0x35, 0x97, 0x48, 0x6e, 0x70, 0x28, 0xae, 0x58, 0x97, 0x7d, 0xf2, 0x19, 0x27, 0x13, 0xab,
	0x47, 0x9b, 0x54, 0xdf, 0xc3, 0x5b, 0x5f, 0x5e, 0xb4, 0x64, 0x47, 0xce, 0x40, 0x3b, 0x0c, 0x4a,
	0x62, 0x52, 0xba, 0xc7, 0xf0, 0x36, 0x87, 0x9c, 0x79, 0x9a, 0x83, 0x11, 0x61, 0x0c, 0x1b, 0x6b
};

char dh_except_b_pubkey_1024[] = {
	0x4a, 0xf3, 0x2c, 0xd2, 0x2d, 0x55, 0xc1, 0x54, 0x40, 0x18, 0x71, 0x7,  0x96, 0xa9, 0x56, 0x6e,
	0x45, 0x58, 0x24, 0xce, 0x75, 0x80, 0x3,  0x68, 0x36, 0x96, 0x3,  0xb2, 0x9c, 0x25, 0xbc, 0x55,
	0x0d, 0xe8, 0xa1, 0x7d, 0xdd, 0x39, 0x87, 0x3c, 0xa1, 0x6a, 0xeb, 0x1b, 0x4f, 0x14, 0x72, 0x88,
	0x6c, 0x14, 0x6d, 0x24, 0xb7, 0xda, 0xf8, 0x97, 0xaa, 0xba, 0xb4, 0xdd, 0xc9, 0x5b, 0x28, 0x10,
	0x49, 0xfa, 0x93, 0xcc, 0x62, 0xc0, 0x70, 0xf8, 0xd6, 0xdc, 0xb2, 0x80, 0x35, 0x20, 0x84, 0xa4,
	0x99, 0xfc, 0x10, 0x7c, 0x9d, 0xc0, 0xc6, 0xd4, 0x8b, 0x0c, 0x57, 0xf1, 0x1,  0xf5, 0x1a, 0x4f,
	0x20, 0xfa, 0x8d, 0x66, 0x8b, 0x22, 0x3c, 0x96, 0xef, 0xd0, 0xde, 0xe5, 0x7e, 0x7f, 0x23, 0xdc,
	0x6d, 0x71, 0xdf, 0xc3, 0xe5, 0x1b, 0x39, 0xfe, 0xb7, 0x77, 0xe5, 0x72, 0x0d, 0x1c, 0x8d, 0xb7
};

char dh_share_key_1024[] = {
	0xcc, 0x48, 0x97, 0xe4, 0x21, 0x65, 0xa6, 0x55, 0xb8, 0xf3, 0xb2, 0x7b, 0x91, 0xd7, 0xca, 0xb9,
	0x17, 0x58, 0x31, 0x71, 0xc0, 0xc9, 0x69, 0x1e, 0xf0, 0x9e, 0x3f, 0xe2, 0x37, 0x4,  0x2d, 0xa8,
	0x55, 0x9,  0x6b, 0x9c, 0xc6, 0x37, 0xa9, 0x9b, 0xdf, 0x67, 0x73, 0x7b, 0x46, 0xf9, 0x63, 0x47,
	0xcb, 0xa0, 0x57, 0x2a, 0xed, 0x97, 0x2f, 0xfe, 0x92, 0xf2, 0x20, 0x2c, 0x7e, 0xee, 0x7d, 0x11,
	0x78, 0xe6, 0xb9, 0x9,  0xd1, 0x94, 0xce, 0xd1, 0x5b, 0xf4, 0x44, 0xa9, 0xcb, 0x26, 0x2,  0x36,
	0x57, 0x2c, 0xa2, 0xbe, 0x37, 0xde, 0x86, 0x46, 0x20, 0x27, 0x9d, 0xa0, 0x2f, 0x4,  0xc1, 0xcd,
	0xff, 0x81, 0xe5, 0xe6, 0x2c, 0x9e, 0x39, 0x82, 0x31, 0x54, 0x33, 0xf8, 0xe7, 0xa0, 0xe5, 0x96,
	0xa4, 0x40, 0xc4, 0x44, 0xfe, 0x93, 0x66, 0xe2, 0xda, 0xaa, 0xb8, 0xfb, 0x2f, 0x3b, 0x8c, 0xce,
};

char dh_p_1536[] = {
	0xe3,0x7d,0xa7,0x4a,0xcc,0xef,0xce,0xa6,0xde,0x1d,0x3d,0xc5,0x2b,0xaa,0x6b,0x83,
	0xec,0x87,0x60,0xcd,0xc6,0xe4,0x16,0x0d,0xe7,0xb9,0x20,0x0e,0x10,0x50,0x35,0x22,
	0xd6,0xdb,0xbf,0x6,0xcc,0x7b,0x8e,0xe1,0x68,0x38,0x76,0x5f,0x0a,0x68,0xa8,0xfd,
	0x3f,0x40,0x51,0x46,0x45,0x64,0x53,0x22,0xcf,0x8,0xe2,0xef,0xd2,0x6f,0x28,0x84,
	0x14,0xb3,0xa6,0x24,0x49,0x6f,0x49,0x6c,0x0a,0x13,0xb6,0x78,0x4f,0xa4,0xd0,0xc4,
	0x20,0x6c,0x7,0x4c,0x6b,0xf7,0x8c,0x72,0x16,0x6c,0x99,0xd2,0x44,0x9e,0x63,0x5,
	0xfc,0x3a,0xa9,0x33,0x16,0x0b,0xc4,0x1a,0xf0,0xc7,0x25,0xcd,0xc6,0x3a,0x8e,0x66,
	0xa2,0xeb,0x70,0xb9,0x59,0xd9,0xb7,0xdd,0x68,0x45,0x26,0x20,0xfa,0x58,0x6f,0xd6,
	0x3f,0xd8,0xf2,0x52,0xd5,0x3a,0x16,0x7,0xdd,0xb4,0x63,0x0c,0xfe,0x8,0x67,0xd0,
	0x9f,0x8a,0xe0,0xe9,0x25,0xa0,0x0e,0x5,0x8e,0xe5,0x56,0xa6,0xc3,0x5b,0x0b,0xb5,
	0x41,0x33,0xd0,0xdb,0x89,0xbd,0x3b,0xaf,0x33,0x7e,0xae,0xff,0x20,0xef,0xa9,0x3c,
	0xd7,0xb5,0x45,0x61,0x50,0x76,0x60,0x89,0x6a,0xbb,0x9c,0x3e,0xcb,0xcb,0xdb,0x0b,
};

char dh_xa_1536[] = {
	0x56,0x68,0x23,0x22,0x49,0x24,0xf2,0x21,0xee,0x5f,0x12,0x46,0xe2,0xea,0x69,0x93,
	0x0,0xf5,0x10,0x1d,0x4d,0x96,0x7b,0xa4,0x9d,0xab,0xbe,0xdf,0x8e,0xcc,0xa5,0x0e,
	0x84,0x12,0x4e,0x77,0xc0,0x46,0x6b,0x51,0x11,0x46,0x4f,0x73,0x1e,0x1c,0x1c,0xd1,
	0x3,0xea,0x0e,0x11,0xdb,0xa3,0xa6,0x14,0xdb,0xdc,0x3e,0xc5,0x7f,0x7d,0x7a,0x69,
	0xa1,0x38,0x70,0x95,0xa5,0x2d,0x47,0xa3,0x0f,0xcf,0xf9,0x7c,0x2,0x4e,0x52,0x4c,
	0xd6,0x5b,0x9e,0xf3,0x7f,0x64,0x70,0x13,0x59,0x8e,0x44,0x31,0x92,0x1b,0xb4,0xaa,
	0xf9,0x64,0xfd,0xb7,0x3c,0x81,0xc0,0xf9,0x66,0x5d,0xff,0x9,0x3e,0x26,0xaf,0x1a,
	0xc0,0xd2,0xd9,0x7c,0x0e,0x6f,0x81,0x12,0x82,0x90,0x1b,0x37,0xb7,0x1a,0x7e,0x36,
	0x79,0x15,0xb1,0xe1,0xd5,0x2d,0x72,0xd4,0x47,0xf7,0x30,0x3c,0x17,0xe1,0x76,0x15,
	0xbc,0x17,0xdc,0x9d,0xd9,0xfc,0xfd,0xb6,0xe6,0xbd,0x8e,0x47,0x8d,0xbb,0xa8,0x8a,
	0xe7,0xe7,0x57,0xf2,0xd8,0x80,0x4c,0xdd,0xe7,0xaf,0x29,0xee,0x40,0x4e,0x2,0xad,
	0xec,0xb3,0x18,0x8e,0x4b,0x2d,0xd2,0x28,0x4e,0x58,0x85,0x29,0xe3,0x93,0x1b,0xa7,
};

char dh_xb_1536[] = {
	0x5c, 0xdf, 0x3, 0x2f, 0x18, 0xac, 0xbc, 0xeb, 0x95, 0xa2, 0x33, 0x70, 0x39, 0x13, 0x92, 0x7e,
	0x91, 0x19, 0x89, 0xd4, 0x0,  0xd1, 0xc5, 0x7e, 0x32, 0xb7, 0x4a, 0xd2, 0xff, 0x11, 0x7a, 0x9b,
	0x2,  0x84, 0xd0, 0x8e, 0x19, 0x91, 0x34, 0xc2, 0x5,  0xff, 0xe4, 0xf4, 0xd8, 0xcf, 0xc8, 0xa0,
	0xeb, 0x19, 0xb9, 0x69, 0x60, 0xcd, 0xa8, 0xda, 0x33, 0xbc, 0xa7, 0x80, 0x0,  0x92, 0x27, 0xe0,
	0xe7, 0x34, 0x77, 0x1f, 0xfd, 0x56, 0x0,  0x0c, 0x57, 0x0,  0x6d, 0x47, 0xe4, 0x32, 0xd7, 0x22,
	0x64, 0xa5, 0x33, 0x65, 0x33, 0x3e, 0x7c, 0x4e, 0x9d, 0xa6, 0xb7, 0x8b, 0xd7, 0xaa, 0x72, 0xe5,
	0x9d, 0xd5, 0xb4, 0x25, 0xcb, 0x30, 0x2,  0xfc, 0xb5, 0xae, 0xb3, 0x88, 0x67, 0x55, 0x0a, 0x7e,
	0x9d, 0xe8, 0x32, 0xfb, 0x50, 0x79, 0x4e, 0x9b, 0x21, 0x92, 0x25, 0x3,  0xa0, 0x15, 0x52, 0x3d,
	0x5e, 0x21, 0x0a, 0x9e, 0x3,  0xdd, 0x3f, 0xcc, 0x38, 0xf6, 0xa9, 0xa6, 0xf8, 0xfd, 0x15, 0x7d,
	0x67, 0x4e, 0x14, 0xae, 0x4d, 0xe2, 0x1f, 0x78, 0x77, 0xfb, 0x83, 0x5f, 0x48, 0xa8, 0xc8, 0x21,
	0x8b, 0xd9, 0xf8, 0x14, 0xe6, 0x42, 0x95, 0xbd, 0x9a, 0x96, 0xbe, 0xf4, 0x7d, 0x26, 0x5d, 0xa1,
	0x81, 0x9b, 0x1c, 0xec, 0xfe, 0xce, 0x9,  0x1d, 0xb7, 0x7a, 0xba, 0xca, 0x7f, 0x54, 0xee, 0x36,
};

char dh_except_a_pubkey_1536[] = {
	0x97,0x1e,0x6d,0xf7,0xb1,0x2f,0xa7,0x82,0x9e,0x99,0x22,0xfb,0xf3,0x4e,0x2a,0x73,
	0xcc,0xd9,0x2b,0x10,0x1,0xfb,0xac,0xf1,0x81,0xfe,0x78,0x3d,0x23,0xb0,0xcf,0x5c,
	0x95,0x69,0x36,0xc0,0x99,0x6a,0xd2,0x9c,0xf0,0x85,0x8d,0xda,0x5d,0xba,0x8e,0x0f,
	0xa3,0xce,0xbe,0x9b,0xe8,0x3b,0xad,0x71,0xfd,0xfd,0x53,0x25,0xee,0x61,0x26,0x15,
	0x0a,0x46,0x9e,0xce,0x85,0xb1,0x5c,0xf1,0xa0,0x8f,0xe7,0x89,0xe3,0x4f,0x7c,0xea,
	0x18,0xd3,0xa9,0x44,0xce,0x35,0x9,0x86,0x80,0x8c,0x30,0x1,0xbc,0x6d,0xf6,0x6a,
	0x3a,0xa6,0xad,0xbe,0xfa,0x73,0x6b,0xb0,0x35,0x8c,0x63,0x80,0xb6,0x58,0x51,0x6e,
	0x4c,0x5d,0x4a,0xe9,0xa9,0x72,0x6,0x9f,0xa2,0x3e,0x64,0xaf,0x70,0x63,0xee,0x2a,
	0x5d,0x73,0xf3,0xdc,0xa3,0x32,0x0f,0x8,0x48,0xcf,0x13,0x80,0x0d,0xdb,0x91,0xdf,
	0x87,0x99,0xa4,0x8a,0x50,0xe9,0x75,0x43,0xfb,0x56,0xd7,0x89,0xc3,0x10,0x7e,0xd0,
	0xb7,0x46,0xd8,0x41,0x91,0xdf,0xb1,0x91,0x8e,0xc1,0x58,0xd7,0x7c,0x33,0x1e,0xb3,
	0xa3,0xda,0xcb,0xf5,0x0,0x76,0xe4,0xee,0x20,0xd6,0x9d,0x8a,0x28,0xa4,0xdb,0xf9,
};

char dh_except_b_pubkey_1536[] = {
	0x44, 0x58, 0xe8, 0x62, 0xc8, 0xd2, 0xb5, 0x45, 0x1f, 0xa5, 0xc3, 0xdb, 0x8e, 0x69, 0x42, 0xd2,
	0x21, 0x7e, 0x6b, 0x26, 0x69, 0x45, 0xf1, 0x33, 0xcf, 0xd7, 0xe6, 0x6e, 0x64, 0xc3, 0x29, 0xa5,
	0x68, 0x49, 0x3d, 0x13, 0x0b, 0x42, 0x36, 0xa6, 0xf4, 0xb1, 0xab, 0xa3, 0x8f, 0xe6, 0xcf, 0x46,
	0xe8, 0x85, 0xf3, 0xaa, 0xcb, 0x9,  0x84, 0x32, 0x34, 0xf7, 0x46, 0x0a, 0x65, 0xf9, 0xb5, 0x97,
	0xc2, 0x4a, 0x6f, 0x41, 0x40, 0xc9, 0x9e, 0x63, 0xe1, 0x0f, 0xd2, 0x12, 0x59, 0x35, 0xcc, 0x39,
	0x99, 0x4, 0xe8, 0x9a, 0xd2, 0x0,  0x7a, 0xce, 0x3c, 0x78, 0xfe, 0xea, 0x4b, 0x13, 0x53, 0xcd,
	0xc3, 0x60, 0x73, 0xa4, 0x3f, 0xbc, 0x8a, 0x8d, 0x61, 0x1c, 0xfa, 0xaf, 0xb7, 0xf8, 0x37, 0xa5,
	0xe2, 0x3a, 0xd2, 0x7a, 0xb6, 0x0,  0xf3, 0xd8, 0x3a, 0xa2, 0x46, 0xd2, 0x5c, 0x91, 0xc1, 0x5,
	0x6a, 0xf3, 0x2c, 0xd2, 0x2d, 0x55, 0xc1, 0x54, 0x40, 0x18, 0x71, 0x7,  0x96, 0xa9, 0x56, 0x6e,
	0x45, 0x58, 0x24, 0xce, 0x75, 0x80, 0x3,  0x68, 0x36, 0x96, 0x3,  0xb2, 0x9c, 0x25, 0xbc, 0x55,
	0x0d, 0xe8, 0xa1, 0x7d, 0xdd, 0x39, 0x87, 0x3c, 0xa1, 0x6a, 0xeb, 0x1b, 0x4f, 0x14, 0x72, 0x88,
	0x6c, 0x14, 0x6d, 0x24, 0xb7, 0xda, 0xf8, 0x97, 0xaa, 0xba, 0xb4, 0xdd, 0xc9, 0x5b, 0x28, 0x10,
};

char dh_share_key_1536[] = {
	0xaf, 0xd4, 0xf6, 0x45, 0x63, 0x21, 0x8d, 0x98, 0xc4, 0xab, 0x18, 0xd7, 0x2b, 0x3c, 0x1d, 0xde,
	0xe7, 0x1f, 0xe1, 0xc5, 0x79, 0x57, 0x60, 0x20, 0xfa, 0x99, 0xbd, 0x7b, 0xa2, 0x94, 0x0b, 0xa3,
	0xb4, 0xb3, 0x33, 0x4a, 0x2f, 0xd0, 0x17, 0x7,  0x2e, 0x70, 0x19, 0x84, 0x1f, 0x8e, 0xe9, 0x61,
	0xe5, 0x52, 0x3, 0x96, 0xea, 0xd8, 0xb6, 0x3,  0x9f, 0xc4, 0x3e, 0x23, 0x77, 0x17, 0x54, 0xfb,
	0x13, 0xf0, 0x3e, 0x9a, 0x27, 0x5d, 0x12, 0x99, 0x58, 0x8d, 0x41, 0x46, 0xd9, 0xc9, 0x29, 0xbd,
	0x40, 0xd1, 0x4f, 0xef, 0x63, 0x7b, 0x54, 0xe6, 0x59, 0x6d, 0xe2, 0x30, 0xe8, 0x2c, 0x2f, 0xf9,
	0x66, 0xa2, 0x12, 0xf5, 0x58, 0x61, 0xac, 0x43, 0xec, 0x7e, 0xf9, 0x2e, 0x27, 0x70, 0x35, 0x75,
	0xb4, 0x10, 0x29, 0xac, 0x0a, 0xab, 0x59, 0xb6, 0x68, 0x4c, 0x16, 0xaf, 0xf0, 0x4f, 0x21, 0xcd,
	0xcc, 0x48, 0x97, 0xe4, 0x21, 0x65, 0xa6, 0x55, 0xb8, 0xf3, 0xb2, 0x7b, 0x91, 0xd7, 0xca, 0xb9,
	0x17, 0x58, 0x31, 0x71, 0xc0, 0xc9, 0x69, 0x1e, 0xf0, 0x9e, 0x3f, 0xe2, 0x37, 0x4,  0x2d, 0xa8,
	0x55, 0x9,  0x6b, 0x9c, 0xc6, 0x37, 0xa9, 0x9b, 0xdf, 0x67, 0x73, 0x7b, 0x46, 0xf9, 0x63, 0x47,
	0xcb, 0xa0, 0x57, 0x2a, 0xed, 0x97, 0x2f, 0xfe, 0x92, 0xf2, 0x20, 0x2c, 0x7e, 0xee, 0x7d, 0x11,
};

char dh_p_2048[] = {
	0xce, 0x58, 0xe8, 0x62, 0xc8, 0xd2, 0xb5, 0x45, 0x1f, 0xa5, 0xc3, 0xdb, 0x8e, 0x69, 0x42, 0xd2,
	0x21, 0x7e, 0x6b, 0x26, 0x69, 0x45, 0xf1, 0x33, 0xcf, 0xd7, 0xe6, 0x6e, 0x64, 0xc3, 0x29, 0xa5,
	0x68, 0x49, 0x3d, 0x13, 0x0b, 0x42, 0x36, 0xa6, 0xf4, 0xb1, 0xab, 0xa3, 0x8f, 0xe6, 0xcf, 0x46,
	0xe8, 0x85, 0xf3, 0xaa, 0xcb, 0x09, 0x84, 0x32, 0x34, 0xf7, 0x46, 0x0a, 0x65, 0xf9, 0xb5, 0x97,
	0xc2, 0x4a, 0x6f, 0x41, 0x40, 0xc9, 0x9e, 0x63, 0xe1, 0x0f, 0xd2, 0x12, 0x59, 0x35, 0xcc, 0x39,
	0x99, 0x04, 0xe8, 0x9a, 0xd2, 0x00, 0x7a, 0xce, 0x3c, 0x78, 0xfe, 0xea, 0x4b, 0x13, 0x53, 0xcd,
	0xc3, 0x60, 0x73, 0xa4, 0x3f, 0xbc, 0x8a, 0x8d, 0x61, 0x1c, 0xfa, 0xaf, 0xb7, 0xf8, 0x37, 0xa5,
	0xe2, 0x3a, 0xd2, 0x7a, 0xb6, 0x00, 0xf3, 0xd8, 0x3a, 0xa2, 0x46, 0xd2, 0x5c, 0x91, 0xc1, 0x05,
	0x6a, 0xf3, 0x2c, 0xd2, 0x2d, 0x55, 0xc1, 0x54, 0x40, 0x18, 0x71, 0x07, 0x96, 0xa9, 0x56, 0x6e,
	0x45, 0x58, 0x24, 0xce, 0x75, 0x80, 0x3,  0x68, 0x36, 0x96, 0x03, 0xb2, 0x9c, 0x25, 0xbc, 0x55,
	0x0d, 0xe8, 0xa1, 0x7d, 0xdd, 0x39, 0x87, 0x3c, 0xa1, 0x6a, 0xeb, 0x1b, 0x4f, 0x14, 0x72, 0x88,
	0x6c, 0x14, 0x6d, 0x24, 0xb7, 0xda, 0xf8, 0x97, 0xaa, 0xba, 0xb4, 0xdd, 0xc9, 0x5b, 0x28, 0x10,
	0x49, 0xfa, 0x93, 0xcc, 0x62, 0xc0, 0x70, 0xf8, 0xd6, 0xdc, 0xb2, 0x80, 0x35, 0x20, 0x84, 0xa4,
	0x99, 0xfc, 0x10, 0x7c, 0x9d, 0xc0, 0xc6, 0xd4, 0x8b, 0x0c, 0x57, 0xf1, 0x01, 0xf5, 0x1a, 0x4f,
	0x20, 0xfa, 0x8d, 0x66, 0x8b, 0x22, 0x3c, 0x96, 0xef, 0xd0, 0xde, 0xe5, 0x7e, 0x7f, 0x23, 0xdc,
	0x6d, 0x71, 0xdf, 0xc3, 0xe5, 0x1b, 0x39, 0xfe, 0xb7, 0x77, 0xe5, 0x72, 0x0d, 0x1c, 0x8d, 0xb7
};

char dh_xa_2048[] = {
	0x6b, 0x1f, 0xc4, 0x85, 0x98, 0xc3, 0x01, 0xda, 0x39, 0xf0, 0x1b, 0x76, 0x5d, 0x81, 0x1d, 0x1f,
	0xc9, 0x93, 0x95, 0xc1, 0xf8, 0xd1, 0x67, 0x2c, 0xd4, 0x0a, 0x67, 0xf0, 0x40, 0x86, 0x82, 0x7f,
	0x8f, 0x9d, 0x79, 0x04, 0xee, 0x4a, 0x54, 0xc9, 0x9c, 0x7f, 0xda, 0x15, 0x13, 0xc6, 0x95, 0xfb,
	0xfc, 0x7b, 0xe7, 0xd8, 0xde, 0x2a, 0xd8, 0xfd, 0xff, 0xdb, 0xa4, 0x7f, 0x4b, 0x37, 0x5d, 0x42,
	0xb6, 0x46, 0x4c, 0xbc, 0x34, 0x23, 0x99, 0x74, 0xf8, 0x80, 0x1b, 0xc1, 0x97, 0x34, 0xdf, 0x23,
	0x15, 0xa2, 0x8b, 0xec, 0xf3, 0x3e, 0x20, 0x93, 0x63, 0x88, 0x17, 0x70, 0x75, 0xbb, 0x9d, 0xb8,
	0x32, 0xb0, 0xae, 0xb5, 0x24, 0x6a, 0x86, 0xf6, 0xc1, 0x60, 0x41, 0xc4, 0xf4, 0x95, 0x6e, 0x10,
	0x2f, 0xd8, 0x58, 0x56, 0x42, 0x82, 0x71, 0x85, 0x19, 0xde, 0x91, 0xf0, 0x2f, 0x30, 0x0c, 0x63,
	0x0f, 0x2a, 0x77, 0x25, 0x4b, 0xb3, 0xd3, 0x2d, 0xfd, 0x94, 0x8b, 0x53, 0x02, 0x21, 0x40, 0xd7,
	0x36, 0x76, 0xf3, 0xc8, 0xc0, 0x36, 0x3d, 0x23, 0xc9, 0xbd, 0x92, 0x51, 0xf2, 0x4b, 0x83, 0x15,
	0xe0, 0x80, 0x86, 0x24, 0xe2, 0x20, 0x35, 0x97, 0xda, 0x0e, 0x68, 0x39, 0x01, 0xdd, 0x01, 0x87,
	0xa2, 0x47, 0xd2, 0x0d, 0xee, 0xfe, 0xdc, 0x5a, 0x37, 0x23, 0xeb, 0x3d, 0xe8, 0x1e, 0x39, 0x2d,
	0xbf, 0xa6, 0xe9, 0x17, 0x48, 0xe2, 0xea, 0xef, 0x1d, 0x2f, 0xe2, 0xaf, 0x3c, 0xbc, 0xae, 0xa7,
	0x42, 0x9b, 0xa5, 0x7d, 0x47, 0x8a, 0x20, 0xc5, 0xae, 0xa1, 0xe4, 0xe8, 0x1c, 0x05, 0xc0, 0x0a,
	0x05, 0xdc, 0x01, 0x74, 0xde, 0xad, 0xad, 0x07, 0xec, 0x6e, 0x6a, 0xc7, 0xee, 0x0f, 0xb8, 0xbe,
	0xaa, 0x46, 0x61, 0x8c, 0x12, 0x5a, 0xaf, 0x05, 0xff, 0x1b, 0x35, 0x6b, 0xe2, 0x3d, 0x48, 0x4f
};

char dh_xb_2048[] = {
	0x5c, 0xdf, 0x3, 0x2f, 0x18, 0xac, 0xbc, 0xeb, 0x95, 0xa2, 0x33, 0x70, 0x39, 0x13, 0x92, 0x7e,
	0x91, 0x19, 0x89, 0xd4, 0x0,  0xd1, 0xc5, 0x7e, 0x32, 0xb7, 0x4a, 0xd2, 0xff, 0x11, 0x7a, 0x9b,
	0x2,  0x84, 0xd0, 0x8e, 0x19, 0x91, 0x34, 0xc2, 0x5,  0xff, 0xe4, 0xf4, 0xd8, 0xcf, 0xc8, 0xa0,
	0xeb, 0x19, 0xb9, 0x69, 0x60, 0xcd, 0xa8, 0xda, 0x33, 0xbc, 0xa7, 0x80, 0x0,  0x92, 0x27, 0xe0,
	0xe7, 0x34, 0x77, 0x1f, 0xfd, 0x56, 0x0,  0x0c, 0x57, 0x0,  0x6d, 0x47, 0xe4, 0x32, 0xd7, 0x22,
	0x64, 0xa5, 0x33, 0x65, 0x33, 0x3e, 0x7c, 0x4e, 0x9d, 0xa6, 0xb7, 0x8b, 0xd7, 0xaa, 0x72, 0xe5,
	0x9d, 0xd5, 0xb4, 0x25, 0xcb, 0x30, 0x2,  0xfc, 0xb5, 0xae, 0xb3, 0x88, 0x67, 0x55, 0x0a, 0x7e,
	0x9d, 0xe8, 0x32, 0xfb, 0x50, 0x79, 0x4e, 0x9b, 0x21, 0x92, 0x25, 0x3,  0xa0, 0x15, 0x52, 0x3d,
	0x5e, 0x21, 0x0a, 0x9e, 0x3,  0xdd, 0x3f, 0xcc, 0x38, 0xf6, 0xa9, 0xa6, 0xf8, 0xfd, 0x15, 0x7d,
	0x67, 0x4e, 0x14, 0xae, 0x4d, 0xe2, 0x1f, 0x78, 0x77, 0xfb, 0x83, 0x5f, 0x48, 0xa8, 0xc8, 0x21,
	0x8b, 0xd9, 0xf8, 0x14, 0xe6, 0x42, 0x95, 0xbd, 0x9a, 0x96, 0xbe, 0xf4, 0x7d, 0x26, 0x5d, 0xa1,
	0x81, 0x9b, 0x1c, 0xec, 0xfe, 0xce, 0x9,  0x1d, 0xb7, 0x7a, 0xba, 0xca, 0x7f, 0x54, 0xee, 0x36,
	0x54, 0x65, 0x4a, 0xd0, 0x5c, 0x84, 0x8c, 0x3e, 0x1b, 0xfe, 0x91, 0x6f, 0x95, 0xb5, 0x76, 0xbf,
	0x61, 0x2a, 0x7, 0x23, 0x86, 0xb9, 0xe0, 0x19, 0x29, 0xcf, 0xea, 0x3a, 0x1,  0xbf, 0xee, 0x1b,
	0x5e, 0x3c, 0x4, 0xff, 0x1d, 0xcf, 0xa6, 0x56, 0xb3, 0x22, 0xbb, 0x45, 0x4b, 0x7f, 0x83, 0x87,
	0xef, 0x21, 0x5, 0xf7, 0x38, 0x1f, 0x6,  0x4d, 0x71, 0x0b, 0xe3, 0xe1, 0xb7, 0x7e, 0xae, 0x18
};

char dh_except_a_pubkey_2048[] = {
	0xa5, 0x24, 0x63, 0x20, 0xb2, 0x56, 0x9a, 0x94, 0x97, 0xf7, 0x88, 0x41, 0x35, 0xeb, 0x52, 0x37,
	0xa4, 0xf2, 0x74, 0x1b, 0x38, 0xe4, 0x4c, 0x8b, 0x4b, 0xd2, 0xa5, 0xad, 0xb8, 0x2f, 0x7b, 0x5a,
	0xfd, 0xbc, 0x9c, 0xe0, 0xea, 0x9e, 0x82, 0x3,  0x62, 0xe2, 0xdc, 0x6c, 0x56, 0x9,  0x2,  0x28,
	0xb8, 0x2d, 0xb8, 0x46, 0xaf, 0x3a, 0xf4, 0x51, 0xf7, 0x4d, 0xc4, 0xd9, 0xa9, 0x1d, 0x67, 0x9d,
	0x2b, 0x18, 0x56, 0x86, 0x2a, 0x3,  0x19, 0xe9, 0x6,  0xeb, 0x4a, 0x6f, 0x2a, 0x40, 0x28, 0xbb,
	0x3e, 0x87, 0xc1, 0xce, 0x39, 0x6e, 0x3b, 0x1f, 0xb0, 0x9,  0x33, 0x67, 0x19, 0x0e, 0x1a, 0xb2,
	0xb3, 0x7d, 0xd3, 0xe6, 0x33, 0xf4, 0x7c, 0x82, 0x73, 0x7b, 0xb6, 0x16, 0x55, 0xff, 0x76, 0xaf,
	0x7f, 0xc2, 0x42, 0x51, 0xa9, 0xad, 0x1e, 0x72, 0xc9, 0x63, 0xab, 0x41, 0x5a, 0x26, 0x32, 0x39,
	0x5d, 0xa6, 0x7,  0x56, 0x93, 0x89, 0xe5, 0x0f, 0x2a, 0xb5, 0x67, 0x3a, 0xcf, 0xc3, 0x82, 0x83,
	0xf6, 0x88, 0x52, 0x0b, 0xfc, 0x6a, 0x5b, 0x1a, 0x57, 0x87, 0x86, 0xef, 0xda, 0x47, 0xdb, 0x4d,
	0xba, 0xe7, 0x3,  0x5b, 0xe4, 0x70, 0x8b, 0xe0, 0xe1, 0x92, 0x13, 0x86, 0x74, 0x4,  0xdc, 0x6a,
	0x0a, 0x2a, 0x20, 0xec, 0x6d, 0xbf, 0xf0, 0x46, 0xf7, 0x9,  0x2,  0xdb, 0x2f, 0x70, 0x11, 0xdd,
	0xb0, 0x13, 0xa2, 0xc1, 0x58, 0x74, 0x29, 0x19, 0x8d, 0x4a, 0x94, 0x80, 0x0b, 0xd7, 0x25, 0x85,
	0x10, 0x35, 0x97, 0x48, 0x6e, 0x70, 0x28, 0xae, 0x58, 0x97, 0x7d, 0xf2, 0x19, 0x27, 0x13, 0xab,
	0x47, 0x9b, 0x54, 0xdf, 0xc3, 0x5b, 0x5f, 0x5e, 0xb4, 0x64, 0x47, 0xce, 0x40, 0x3b, 0x0c, 0x4a,
	0x62, 0x52, 0xba, 0xc7, 0xf0, 0x36, 0x87, 0x9c, 0x79, 0x9a, 0x83, 0x11, 0x61, 0x0c, 0x1b, 0x6b
};

char dh_except_b_pubkey_2048[] = {
	0x44, 0x58, 0xe8, 0x62, 0xc8, 0xd2, 0xb5, 0x45, 0x1f, 0xa5, 0xc3, 0xdb, 0x8e, 0x69, 0x42, 0xd2,
	0x21, 0x7e, 0x6b, 0x26, 0x69, 0x45, 0xf1, 0x33, 0xcf, 0xd7, 0xe6, 0x6e, 0x64, 0xc3, 0x29, 0xa5,
	0x68, 0x49, 0x3d, 0x13, 0x0b, 0x42, 0x36, 0xa6, 0xf4, 0xb1, 0xab, 0xa3, 0x8f, 0xe6, 0xcf, 0x46,
	0xe8, 0x85, 0xf3, 0xaa, 0xcb, 0x9,  0x84, 0x32, 0x34, 0xf7, 0x46, 0x0a, 0x65, 0xf9, 0xb5, 0x97,
	0xc2, 0x4a, 0x6f, 0x41, 0x40, 0xc9, 0x9e, 0x63, 0xe1, 0x0f, 0xd2, 0x12, 0x59, 0x35, 0xcc, 0x39,
	0x99, 0x4, 0xe8, 0x9a, 0xd2, 0x0,  0x7a, 0xce, 0x3c, 0x78, 0xfe, 0xea, 0x4b, 0x13, 0x53, 0xcd,
	0xc3, 0x60, 0x73, 0xa4, 0x3f, 0xbc, 0x8a, 0x8d, 0x61, 0x1c, 0xfa, 0xaf, 0xb7, 0xf8, 0x37, 0xa5,
	0xe2, 0x3a, 0xd2, 0x7a, 0xb6, 0x0,  0xf3, 0xd8, 0x3a, 0xa2, 0x46, 0xd2, 0x5c, 0x91, 0xc1, 0x5,
	0x6a, 0xf3, 0x2c, 0xd2, 0x2d, 0x55, 0xc1, 0x54, 0x40, 0x18, 0x71, 0x7,  0x96, 0xa9, 0x56, 0x6e,
	0x45, 0x58, 0x24, 0xce, 0x75, 0x80, 0x3,  0x68, 0x36, 0x96, 0x3,  0xb2, 0x9c, 0x25, 0xbc, 0x55,
	0x0d, 0xe8, 0xa1, 0x7d, 0xdd, 0x39, 0x87, 0x3c, 0xa1, 0x6a, 0xeb, 0x1b, 0x4f, 0x14, 0x72, 0x88,
	0x6c, 0x14, 0x6d, 0x24, 0xb7, 0xda, 0xf8, 0x97, 0xaa, 0xba, 0xb4, 0xdd, 0xc9, 0x5b, 0x28, 0x10,
	0x49, 0xfa, 0x93, 0xcc, 0x62, 0xc0, 0x70, 0xf8, 0xd6, 0xdc, 0xb2, 0x80, 0x35, 0x20, 0x84, 0xa4,
	0x99, 0xfc, 0x10, 0x7c, 0x9d, 0xc0, 0xc6, 0xd4, 0x8b, 0x0c, 0x57, 0xf1, 0x1,  0xf5, 0x1a, 0x4f,
	0x20, 0xfa, 0x8d, 0x66, 0x8b, 0x22, 0x3c, 0x96, 0xef, 0xd0, 0xde, 0xe5, 0x7e, 0x7f, 0x23, 0xdc,
	0x6d, 0x71, 0xdf, 0xc3, 0xe5, 0x1b, 0x39, 0xfe, 0xb7, 0x77, 0xe5, 0x72, 0x0d, 0x1c, 0x8d, 0xb7
};

char dh_share_key_2048[] = {
	0xaf, 0xd4, 0xf6, 0x45, 0x63, 0x21, 0x8d, 0x98, 0xc4, 0xab, 0x18, 0xd7, 0x2b, 0x3c, 0x1d, 0xde,
	0xe7, 0x1f, 0xe1, 0xc5, 0x79, 0x57, 0x60, 0x20, 0xfa, 0x99, 0xbd, 0x7b, 0xa2, 0x94, 0x0b, 0xa3,
	0xb4, 0xb3, 0x33, 0x4a, 0x2f, 0xd0, 0x17, 0x7,  0x2e, 0x70, 0x19, 0x84, 0x1f, 0x8e, 0xe9, 0x61,
	0xe5, 0x52, 0x3, 0x96, 0xea, 0xd8, 0xb6, 0x3,  0x9f, 0xc4, 0x3e, 0x23, 0x77, 0x17, 0x54, 0xfb,
	0x13, 0xf0, 0x3e, 0x9a, 0x27, 0x5d, 0x12, 0x99, 0x58, 0x8d, 0x41, 0x46, 0xd9, 0xc9, 0x29, 0xbd,
	0x40, 0xd1, 0x4f, 0xef, 0x63, 0x7b, 0x54, 0xe6, 0x59, 0x6d, 0xe2, 0x30, 0xe8, 0x2c, 0x2f, 0xf9,
	0x66, 0xa2, 0x12, 0xf5, 0x58, 0x61, 0xac, 0x43, 0xec, 0x7e, 0xf9, 0x2e, 0x27, 0x70, 0x35, 0x75,
	0xb4, 0x10, 0x29, 0xac, 0x0a, 0xab, 0x59, 0xb6, 0x68, 0x4c, 0x16, 0xaf, 0xf0, 0x4f, 0x21, 0xcd,
	0xcc, 0x48, 0x97, 0xe4, 0x21, 0x65, 0xa6, 0x55, 0xb8, 0xf3, 0xb2, 0x7b, 0x91, 0xd7, 0xca, 0xb9,
	0x17, 0x58, 0x31, 0x71, 0xc0, 0xc9, 0x69, 0x1e, 0xf0, 0x9e, 0x3f, 0xe2, 0x37, 0x4,  0x2d, 0xa8,
	0x55, 0x9,  0x6b, 0x9c, 0xc6, 0x37, 0xa9, 0x9b, 0xdf, 0x67, 0x73, 0x7b, 0x46, 0xf9, 0x63, 0x47,
	0xcb, 0xa0, 0x57, 0x2a, 0xed, 0x97, 0x2f, 0xfe, 0x92, 0xf2, 0x20, 0x2c, 0x7e, 0xee, 0x7d, 0x11,
	0x78, 0xe6, 0xb9, 0x9,  0xd1, 0x94, 0xce, 0xd1, 0x5b, 0xf4, 0x44, 0xa9, 0xcb, 0x26, 0x2,  0x36,
	0x57, 0x2c, 0xa2, 0xbe, 0x37, 0xde, 0x86, 0x46, 0x20, 0x27, 0x9d, 0xa0, 0x2f, 0x4,  0xc1, 0xcd,
	0xff, 0x81, 0xe5, 0xe6, 0x2c, 0x9e, 0x39, 0x82, 0x31, 0x54, 0x33, 0xf8, 0xe7, 0xa0, 0xe5, 0x96,
	0xa4, 0x40, 0xc4, 0x44, 0xfe, 0x93, 0x66, 0xe2, 0xda, 0xaa, 0xb8, 0xfb, 0x2f, 0x3b, 0x8c, 0xce,
};

char dh_p_3072[] = {
	0xce, 0x58, 0xe8, 0x62, 0xc8, 0xd2, 0xb5, 0x45, 0x1f, 0xa5, 0xc3, 0xdb, 0x8e, 0x69, 0x42, 0xd2,
	0x21, 0x7e, 0x6b, 0x26, 0x69, 0x45, 0xf1, 0x33, 0xcf, 0xd7, 0xe6, 0x6e, 0x64, 0xc3, 0x29, 0xa5,
	0x68, 0x49, 0x3d, 0x13, 0x0b, 0x42, 0x36, 0xa6, 0xf4, 0xb1, 0xab, 0xa3, 0x8f, 0xe6, 0xcf, 0x46,
	0xe8, 0x85, 0xf3, 0xaa, 0xcb, 0x09, 0x84, 0x32, 0x34, 0xf7, 0x46, 0x0a, 0x65, 0xf9, 0xb5, 0x97,
	0xc2, 0x4a, 0x6f, 0x41, 0x40, 0xc9, 0x9e, 0x63, 0xe1, 0x0f, 0xd2, 0x12, 0x59, 0x35, 0xcc, 0x39,
	0x99, 0x04, 0xe8, 0x9a, 0xd2, 0x00, 0x7a, 0xce, 0x3c, 0x78, 0xfe, 0xea, 0x4b, 0x13, 0x53, 0xcd,
	0xc3, 0x60, 0x73, 0xa4, 0x3f, 0xbc, 0x8a, 0x8d, 0x61, 0x1c, 0xfa, 0xaf, 0xb7, 0xf8, 0x37, 0xa5,
	0xe2, 0x3a, 0xd2, 0x7a, 0xb6, 0x00, 0xf3, 0xd8, 0x3a, 0xa2, 0x46, 0xd2, 0x5c, 0x91, 0xc1, 0x05,
	0x6a, 0xf3, 0x2c, 0xd2, 0x2d, 0x55, 0xc1, 0x54, 0x40, 0x18, 0x71, 0x07, 0x96, 0xa9, 0x56, 0x6e,
	0x45, 0x58, 0x24, 0xce, 0x75, 0x80, 0x3,  0x68, 0x36, 0x96, 0x03, 0xb2, 0x9c, 0x25, 0xbc, 0x55,
	0x0d, 0xe8, 0xa1, 0x7d, 0xdd, 0x39, 0x87, 0x3c, 0xa1, 0x6a, 0xeb, 0x1b, 0x4f, 0x14, 0x72, 0x88,
	0x6c, 0x14, 0x6d, 0x24, 0xb7, 0xda, 0xf8, 0x97, 0xaa, 0xba, 0xb4, 0xdd, 0xc9, 0x5b, 0x28, 0x10,
	0x49, 0xfa, 0x93, 0xcc, 0x62, 0xc0, 0x70, 0xf8, 0xd6, 0xdc, 0xb2, 0x80, 0x35, 0x20, 0x84, 0xa4,
	0x99, 0xfc, 0x10, 0x7c, 0x9d, 0xc0, 0xc6, 0xd4, 0x8b, 0x0c, 0x57, 0xf1, 0x01, 0xf5, 0x1a, 0x4f,
	0x20, 0xfa, 0x8d, 0x66, 0x8b, 0x22, 0x3c, 0x96, 0xef, 0xd0, 0xde, 0xe5, 0x7e, 0x7f, 0x23, 0xdc,
	0x6d, 0x71, 0xdf, 0xc3, 0xe5, 0x1b, 0x39, 0xfe, 0xb7, 0x77, 0xe5, 0x72, 0x0d, 0x1c, 0x8d, 0xb7,
	0xce, 0x58, 0xe8, 0x62, 0xc8, 0xd2, 0xb5, 0x45, 0x1f, 0xa5, 0xc3, 0xdb, 0x8e, 0x69, 0x42, 0xd2,
	0x21, 0x7e, 0x6b, 0x26, 0x69, 0x45, 0xf1, 0x33, 0xcf, 0xd7, 0xe6, 0x6e, 0x64, 0xc3, 0x29, 0xa5,
	0x68, 0x49, 0x3d, 0x13, 0x0b, 0x42, 0x36, 0xa6, 0xf4, 0xb1, 0xab, 0xa3, 0x8f, 0xe6, 0xcf, 0x46,
	0xe8, 0x85, 0xf3, 0xaa, 0xcb, 0x09, 0x84, 0x32, 0x34, 0xf7, 0x46, 0x0a, 0x65, 0xf9, 0xb5, 0x97,
	0xc2, 0x4a, 0x6f, 0x41, 0x40, 0xc9, 0x9e, 0x63, 0xe1, 0x0f, 0xd2, 0x12, 0x59, 0x35, 0xcc, 0x39,
	0x99, 0x04, 0xe8, 0x9a, 0xd2, 0x00, 0x7a, 0xce, 0x3c, 0x78, 0xfe, 0xea, 0x4b, 0x13, 0x53, 0xcd,
	0xc3, 0x60, 0x73, 0xa4, 0x3f, 0xbc, 0x8a, 0x8d, 0x61, 0x1c, 0xfa, 0xaf, 0xb7, 0xf8, 0x37, 0xa5,
	0xe2, 0x3a, 0xd2, 0x7a, 0xb6, 0x00, 0xf3, 0xd8, 0x3a, 0xa2, 0x46, 0xd2, 0x5c, 0x91, 0xc1, 0x05,
};

char dh_xa_3072[] = {
	0x6b, 0x1f, 0xc4, 0x85, 0x98, 0xc3, 0x01, 0xda, 0x39, 0xf0, 0x1b, 0x76, 0x5d, 0x81, 0x1d, 0x1f,
	0xc9, 0x93, 0x95, 0xc1, 0xf8, 0xd1, 0x67, 0x2c, 0xd4, 0x0a, 0x67, 0xf0, 0x40, 0x86, 0x82, 0x7f,
	0x8f, 0x9d, 0x79, 0x04, 0xee, 0x4a, 0x54, 0xc9, 0x9c, 0x7f, 0xda, 0x15, 0x13, 0xc6, 0x95, 0xfb,
	0xfc, 0x7b, 0xe7, 0xd8, 0xde, 0x2a, 0xd8, 0xfd, 0xff, 0xdb, 0xa4, 0x7f, 0x4b, 0x37, 0x5d, 0x42,
	0xb6, 0x46, 0x4c, 0xbc, 0x34, 0x23, 0x99, 0x74, 0xf8, 0x80, 0x1b, 0xc1, 0x97, 0x34, 0xdf, 0x23,
	0x15, 0xa2, 0x8b, 0xec, 0xf3, 0x3e, 0x20, 0x93, 0x63, 0x88, 0x17, 0x70, 0x75, 0xbb, 0x9d, 0xb8,
	0x32, 0xb0, 0xae, 0xb5, 0x24, 0x6a, 0x86, 0xf6, 0xc1, 0x60, 0x41, 0xc4, 0xf4, 0x95, 0x6e, 0x10,
	0x2f, 0xd8, 0x58, 0x56, 0x42, 0x82, 0x71, 0x85, 0x19, 0xde, 0x91, 0xf0, 0x2f, 0x30, 0x0c, 0x63,
	0x0f, 0x2a, 0x77, 0x25, 0x4b, 0xb3, 0xd3, 0x2d, 0xfd, 0x94, 0x8b, 0x53, 0x02, 0x21, 0x40, 0xd7,
	0x36, 0x76, 0xf3, 0xc8, 0xc0, 0x36, 0x3d, 0x23, 0xc9, 0xbd, 0x92, 0x51, 0xf2, 0x4b, 0x83, 0x15,
	0xe0, 0x80, 0x86, 0x24, 0xe2, 0x20, 0x35, 0x97, 0xda, 0x0e, 0x68, 0x39, 0x01, 0xdd, 0x01, 0x87,
	0xa2, 0x47, 0xd2, 0x0d, 0xee, 0xfe, 0xdc, 0x5a, 0x37, 0x23, 0xeb, 0x3d, 0xe8, 0x1e, 0x39, 0x2d,
	0xbf, 0xa6, 0xe9, 0x17, 0x48, 0xe2, 0xea, 0xef, 0x1d, 0x2f, 0xe2, 0xaf, 0x3c, 0xbc, 0xae, 0xa7,
	0x42, 0x9b, 0xa5, 0x7d, 0x47, 0x8a, 0x20, 0xc5, 0xae, 0xa1, 0xe4, 0xe8, 0x1c, 0x05, 0xc0, 0x0a,
	0x05, 0xdc, 0x01, 0x74, 0xde, 0xad, 0xad, 0x07, 0xec, 0x6e, 0x6a, 0xc7, 0xee, 0x0f, 0xb8, 0xbe,
	0xaa, 0x46, 0x61, 0x8c, 0x12, 0x5a, 0xaf, 0x05, 0xff, 0x1b, 0x35, 0x6b, 0xe2, 0x3d, 0x48, 0x4f,
	0x6b, 0x1f, 0xc4, 0x85, 0x98, 0xc3, 0x01, 0xda, 0x39, 0xf0, 0x1b, 0x76, 0x5d, 0x81, 0x1d, 0x1f,
	0xc9, 0x93, 0x95, 0xc1, 0xf8, 0xd1, 0x67, 0x2c, 0xd4, 0x0a, 0x67, 0xf0, 0x40, 0x86, 0x82, 0x7f,
	0x8f, 0x9d, 0x79, 0x04, 0xee, 0x4a, 0x54, 0xc9, 0x9c, 0x7f, 0xda, 0x15, 0x13, 0xc6, 0x95, 0xfb,
	0xfc, 0x7b, 0xe7, 0xd8, 0xde, 0x2a, 0xd8, 0xfd, 0xff, 0xdb, 0xa4, 0x7f, 0x4b, 0x37, 0x5d, 0x42,
	0xb6, 0x46, 0x4c, 0xbc, 0x34, 0x23, 0x99, 0x74, 0xf8, 0x80, 0x1b, 0xc1, 0x97, 0x34, 0xdf, 0x23,
	0x15, 0xa2, 0x8b, 0xec, 0xf3, 0x3e, 0x20, 0x93, 0x63, 0x88, 0x17, 0x70, 0x75, 0xbb, 0x9d, 0xb8,
	0x32, 0xb0, 0xae, 0xb5, 0x24, 0x6a, 0x86, 0xf6, 0xc1, 0x60, 0x41, 0xc4, 0xf4, 0x95, 0x6e, 0x10,
	0x2f, 0xd8, 0x58, 0x56, 0x42, 0x82, 0x71, 0x85, 0x19, 0xde, 0x91, 0xf0, 0x2f, 0x30, 0x0c, 0x63,
};

char dh_xb_3072[] = {
	0x5c, 0xdf, 0x3, 0x2f, 0x18, 0xac, 0xbc, 0xeb, 0x95, 0xa2, 0x33, 0x70, 0x39, 0x13, 0x92, 0x7e,
	0x91, 0x19, 0x89, 0xd4, 0x0,  0xd1, 0xc5, 0x7e, 0x32, 0xb7, 0x4a, 0xd2, 0xff, 0x11, 0x7a, 0x9b,
	0x2,  0x84, 0xd0, 0x8e, 0x19, 0x91, 0x34, 0xc2, 0x5,  0xff, 0xe4, 0xf4, 0xd8, 0xcf, 0xc8, 0xa0,
	0xeb, 0x19, 0xb9, 0x69, 0x60, 0xcd, 0xa8, 0xda, 0x33, 0xbc, 0xa7, 0x80, 0x0,  0x92, 0x27, 0xe0,
	0xe7, 0x34, 0x77, 0x1f, 0xfd, 0x56, 0x0,  0x0c, 0x57, 0x0,  0x6d, 0x47, 0xe4, 0x32, 0xd7, 0x22,
	0x64, 0xa5, 0x33, 0x65, 0x33, 0x3e, 0x7c, 0x4e, 0x9d, 0xa6, 0xb7, 0x8b, 0xd7, 0xaa, 0x72, 0xe5,
	0x9d, 0xd5, 0xb4, 0x25, 0xcb, 0x30, 0x2,  0xfc, 0xb5, 0xae, 0xb3, 0x88, 0x67, 0x55, 0x0a, 0x7e,
	0x9d, 0xe8, 0x32, 0xfb, 0x50, 0x79, 0x4e, 0x9b, 0x21, 0x92, 0x25, 0x3,  0xa0, 0x15, 0x52, 0x3d,
	0x5e, 0x21, 0x0a, 0x9e, 0x3,  0xdd, 0x3f, 0xcc, 0x38, 0xf6, 0xa9, 0xa6, 0xf8, 0xfd, 0x15, 0x7d,
	0x67, 0x4e, 0x14, 0xae, 0x4d, 0xe2, 0x1f, 0x78, 0x77, 0xfb, 0x83, 0x5f, 0x48, 0xa8, 0xc8, 0x21,
	0x8b, 0xd9, 0xf8, 0x14, 0xe6, 0x42, 0x95, 0xbd, 0x9a, 0x96, 0xbe, 0xf4, 0x7d, 0x26, 0x5d, 0xa1,
	0x81, 0x9b, 0x1c, 0xec, 0xfe, 0xce, 0x9,  0x1d, 0xb7, 0x7a, 0xba, 0xca, 0x7f, 0x54, 0xee, 0x36,
	0x54, 0x65, 0x4a, 0xd0, 0x5c, 0x84, 0x8c, 0x3e, 0x1b, 0xfe, 0x91, 0x6f, 0x95, 0xb5, 0x76, 0xbf,
	0x61, 0x2a, 0x7, 0x23, 0x86, 0xb9, 0xe0, 0x19, 0x29, 0xcf, 0xea, 0x3a, 0x1,  0xbf, 0xee, 0x1b,
	0x5e, 0x3c, 0x4, 0xff, 0x1d, 0xcf, 0xa6, 0x56, 0xb3, 0x22, 0xbb, 0x45, 0x4b, 0x7f, 0x83, 0x87,
	0xef, 0x21, 0x5, 0xf7, 0x38, 0x1f, 0x6,  0x4d, 0x71, 0x0b, 0xe3, 0xe1, 0xb7, 0x7e, 0xae, 0x18,
	0x5c, 0xdf, 0x3, 0x2f, 0x18, 0xac, 0xbc, 0xeb, 0x95, 0xa2, 0x33, 0x70, 0x39, 0x13, 0x92, 0x7e,
	0x91, 0x19, 0x89, 0xd4, 0x0,  0xd1, 0xc5, 0x7e, 0x32, 0xb7, 0x4a, 0xd2, 0xff, 0x11, 0x7a, 0x9b,
	0x2,  0x84, 0xd0, 0x8e, 0x19, 0x91, 0x34, 0xc2, 0x5,  0xff, 0xe4, 0xf4, 0xd8, 0xcf, 0xc8, 0xa0,
	0xeb, 0x19, 0xb9, 0x69, 0x60, 0xcd, 0xa8, 0xda, 0x33, 0xbc, 0xa7, 0x80, 0x0,  0x92, 0x27, 0xe0,
	0xe7, 0x34, 0x77, 0x1f, 0xfd, 0x56, 0x0,  0x0c, 0x57, 0x0,  0x6d, 0x47, 0xe4, 0x32, 0xd7, 0x22,
	0x64, 0xa5, 0x33, 0x65, 0x33, 0x3e, 0x7c, 0x4e, 0x9d, 0xa6, 0xb7, 0x8b, 0xd7, 0xaa, 0x72, 0xe5,
	0x9d, 0xd5, 0xb4, 0x25, 0xcb, 0x30, 0x2,  0xfc, 0xb5, 0xae, 0xb3, 0x88, 0x67, 0x55, 0x0a, 0x7e,
	0x9d, 0xe8, 0x32, 0xfb, 0x50, 0x79, 0x4e, 0x9b, 0x21, 0x92, 0x25, 0x3,  0xa0, 0x15, 0x52, 0x3d,
};

char dh_except_a_pubkey_3072[] = {
	0xa5, 0x24, 0x63, 0x20, 0xb2, 0x56, 0x9a, 0x94, 0x97, 0xf7, 0x88, 0x41, 0x35, 0xeb, 0x52, 0x37,
	0xa4, 0xf2, 0x74, 0x1b, 0x38, 0xe4, 0x4c, 0x8b, 0x4b, 0xd2, 0xa5, 0xad, 0xb8, 0x2f, 0x7b, 0x5a,
	0xfd, 0xbc, 0x9c, 0xe0, 0xea, 0x9e, 0x82, 0x3,  0x62, 0xe2, 0xdc, 0x6c, 0x56, 0x9,  0x2,  0x28,
	0xb8, 0x2d, 0xb8, 0x46, 0xaf, 0x3a, 0xf4, 0x51, 0xf7, 0x4d, 0xc4, 0xd9, 0xa9, 0x1d, 0x67, 0x9d,
	0x2b, 0x18, 0x56, 0x86, 0x2a, 0x3,  0x19, 0xe9, 0x6,  0xeb, 0x4a, 0x6f, 0x2a, 0x40, 0x28, 0xbb,
	0x3e, 0x87, 0xc1, 0xce, 0x39, 0x6e, 0x3b, 0x1f, 0xb0, 0x9,  0x33, 0x67, 0x19, 0x0e, 0x1a, 0xb2,
	0xb3, 0x7d, 0xd3, 0xe6, 0x33, 0xf4, 0x7c, 0x82, 0x73, 0x7b, 0xb6, 0x16, 0x55, 0xff, 0x76, 0xaf,
	0x7f, 0xc2, 0x42, 0x51, 0xa9, 0xad, 0x1e, 0x72, 0xc9, 0x63, 0xab, 0x41, 0x5a, 0x26, 0x32, 0x39,
	0x5d, 0xa6, 0x7,  0x56, 0x93, 0x89, 0xe5, 0x0f, 0x2a, 0xb5, 0x67, 0x3a, 0xcf, 0xc3, 0x82, 0x83,
	0xf6, 0x88, 0x52, 0x0b, 0xfc, 0x6a, 0x5b, 0x1a, 0x57, 0x87, 0x86, 0xef, 0xda, 0x47, 0xdb, 0x4d,
	0xba, 0xe7, 0x3,  0x5b, 0xe4, 0x70, 0x8b, 0xe0, 0xe1, 0x92, 0x13, 0x86, 0x74, 0x4,  0xdc, 0x6a,
	0x0a, 0x2a, 0x20, 0xec, 0x6d, 0xbf, 0xf0, 0x46, 0xf7, 0x9,  0x2,  0xdb, 0x2f, 0x70, 0x11, 0xdd,
	0xb0, 0x13, 0xa2, 0xc1, 0x58, 0x74, 0x29, 0x19, 0x8d, 0x4a, 0x94, 0x80, 0x0b, 0xd7, 0x25, 0x85,
	0x10, 0x35, 0x97, 0x48, 0x6e, 0x70, 0x28, 0xae, 0x58, 0x97, 0x7d, 0xf2, 0x19, 0x27, 0x13, 0xab,
	0x47, 0x9b, 0x54, 0xdf, 0xc3, 0x5b, 0x5f, 0x5e, 0xb4, 0x64, 0x47, 0xce, 0x40, 0x3b, 0x0c, 0x4a,
	0x62, 0x52, 0xba, 0xc7, 0xf0, 0x36, 0x87, 0x9c, 0x79, 0x9a, 0x83, 0x11, 0x61, 0x0c, 0x1b, 0x6b,
	0xa5, 0x24, 0x63, 0x20, 0xb2, 0x56, 0x9a, 0x94, 0x97, 0xf7, 0x88, 0x41, 0x35, 0xeb, 0x52, 0x37,
	0xa4, 0xf2, 0x74, 0x1b, 0x38, 0xe4, 0x4c, 0x8b, 0x4b, 0xd2, 0xa5, 0xad, 0xb8, 0x2f, 0x7b, 0x5a,
	0xfd, 0xbc, 0x9c, 0xe0, 0xea, 0x9e, 0x82, 0x3,  0x62, 0xe2, 0xdc, 0x6c, 0x56, 0x9,  0x2,  0x28,
	0xb8, 0x2d, 0xb8, 0x46, 0xaf, 0x3a, 0xf4, 0x51, 0xf7, 0x4d, 0xc4, 0xd9, 0xa9, 0x1d, 0x67, 0x9d,
	0x2b, 0x18, 0x56, 0x86, 0x2a, 0x3,  0x19, 0xe9, 0x6,  0xeb, 0x4a, 0x6f, 0x2a, 0x40, 0x28, 0xbb,
	0x3e, 0x87, 0xc1, 0xce, 0x39, 0x6e, 0x3b, 0x1f, 0xb0, 0x9,  0x33, 0x67, 0x19, 0x0e, 0x1a, 0xb2,
	0xb3, 0x7d, 0xd3, 0xe6, 0x33, 0xf4, 0x7c, 0x82, 0x73, 0x7b, 0xb6, 0x16, 0x55, 0xff, 0x76, 0xaf,
	0x7f, 0xc2, 0x42, 0x51, 0xa9, 0xad, 0x1e, 0x72, 0xc9, 0x63, 0xab, 0x41, 0x5a, 0x26, 0x32, 0x39,
};

char dh_except_b_pubkey_3072[] = {
	0x44, 0x58, 0xe8, 0x62, 0xc8, 0xd2, 0xb5, 0x45, 0x1f, 0xa5, 0xc3, 0xdb, 0x8e, 0x69, 0x42, 0xd2,
	0x21, 0x7e, 0x6b, 0x26, 0x69, 0x45, 0xf1, 0x33, 0xcf, 0xd7, 0xe6, 0x6e, 0x64, 0xc3, 0x29, 0xa5,
	0x68, 0x49, 0x3d, 0x13, 0x0b, 0x42, 0x36, 0xa6, 0xf4, 0xb1, 0xab, 0xa3, 0x8f, 0xe6, 0xcf, 0x46,
	0xe8, 0x85, 0xf3, 0xaa, 0xcb, 0x9,  0x84, 0x32, 0x34, 0xf7, 0x46, 0x0a, 0x65, 0xf9, 0xb5, 0x97,
	0xc2, 0x4a, 0x6f, 0x41, 0x40, 0xc9, 0x9e, 0x63, 0xe1, 0x0f, 0xd2, 0x12, 0x59, 0x35, 0xcc, 0x39,
	0x99, 0x4, 0xe8, 0x9a, 0xd2, 0x0,  0x7a, 0xce, 0x3c, 0x78, 0xfe, 0xea, 0x4b, 0x13, 0x53, 0xcd,
	0xc3, 0x60, 0x73, 0xa4, 0x3f, 0xbc, 0x8a, 0x8d, 0x61, 0x1c, 0xfa, 0xaf, 0xb7, 0xf8, 0x37, 0xa5,
	0xe2, 0x3a, 0xd2, 0x7a, 0xb6, 0x0,  0xf3, 0xd8, 0x3a, 0xa2, 0x46, 0xd2, 0x5c, 0x91, 0xc1, 0x5,
	0x6a, 0xf3, 0x2c, 0xd2, 0x2d, 0x55, 0xc1, 0x54, 0x40, 0x18, 0x71, 0x7,  0x96, 0xa9, 0x56, 0x6e,
	0x45, 0x58, 0x24, 0xce, 0x75, 0x80, 0x3,  0x68, 0x36, 0x96, 0x3,  0xb2, 0x9c, 0x25, 0xbc, 0x55,
	0x0d, 0xe8, 0xa1, 0x7d, 0xdd, 0x39, 0x87, 0x3c, 0xa1, 0x6a, 0xeb, 0x1b, 0x4f, 0x14, 0x72, 0x88,
	0x6c, 0x14, 0x6d, 0x24, 0xb7, 0xda, 0xf8, 0x97, 0xaa, 0xba, 0xb4, 0xdd, 0xc9, 0x5b, 0x28, 0x10,
	0x49, 0xfa, 0x93, 0xcc, 0x62, 0xc0, 0x70, 0xf8, 0xd6, 0xdc, 0xb2, 0x80, 0x35, 0x20, 0x84, 0xa4,
	0x99, 0xfc, 0x10, 0x7c, 0x9d, 0xc0, 0xc6, 0xd4, 0x8b, 0x0c, 0x57, 0xf1, 0x1,  0xf5, 0x1a, 0x4f,
	0x20, 0xfa, 0x8d, 0x66, 0x8b, 0x22, 0x3c, 0x96, 0xef, 0xd0, 0xde, 0xe5, 0x7e, 0x7f, 0x23, 0xdc,
	0x6d, 0x71, 0xdf, 0xc3, 0xe5, 0x1b, 0x39, 0xfe, 0xb7, 0x77, 0xe5, 0x72, 0x0d, 0x1c, 0x8d, 0xb7,
	0x44, 0x58, 0xe8, 0x62, 0xc8, 0xd2, 0xb5, 0x45, 0x1f, 0xa5, 0xc3, 0xdb, 0x8e, 0x69, 0x42, 0xd2,
	0x21, 0x7e, 0x6b, 0x26, 0x69, 0x45, 0xf1, 0x33, 0xcf, 0xd7, 0xe6, 0x6e, 0x64, 0xc3, 0x29, 0xa5,
	0x68, 0x49, 0x3d, 0x13, 0x0b, 0x42, 0x36, 0xa6, 0xf4, 0xb1, 0xab, 0xa3, 0x8f, 0xe6, 0xcf, 0x46,
	0xe8, 0x85, 0xf3, 0xaa, 0xcb, 0x9,  0x84, 0x32, 0x34, 0xf7, 0x46, 0x0a, 0x65, 0xf9, 0xb5, 0x97,
	0xc2, 0x4a, 0x6f, 0x41, 0x40, 0xc9, 0x9e, 0x63, 0xe1, 0x0f, 0xd2, 0x12, 0x59, 0x35, 0xcc, 0x39,
	0x99, 0x4, 0xe8, 0x9a, 0xd2, 0x0,  0x7a, 0xce, 0x3c, 0x78, 0xfe, 0xea, 0x4b, 0x13, 0x53, 0xcd,
	0xc3, 0x60, 0x73, 0xa4, 0x3f, 0xbc, 0x8a, 0x8d, 0x61, 0x1c, 0xfa, 0xaf, 0xb7, 0xf8, 0x37, 0xa5,
	0xe2, 0x3a, 0xd2, 0x7a, 0xb6, 0x0,  0xf3, 0xd8, 0x3a, 0xa2, 0x46, 0xd2, 0x5c, 0x91, 0xc1, 0x5,
};

char dh_share_key_3072[] = {
	0xaf, 0xd4, 0xf6, 0x45, 0x63, 0x21, 0x8d, 0x98, 0xc4, 0xab, 0x18, 0xd7, 0x2b, 0x3c, 0x1d, 0xde,
	0xe7, 0x1f, 0xe1, 0xc5, 0x79, 0x57, 0x60, 0x20, 0xfa, 0x99, 0xbd, 0x7b, 0xa2, 0x94, 0x0b, 0xa3,
	0xb4, 0xb3, 0x33, 0x4a, 0x2f, 0xd0, 0x17, 0x7,  0x2e, 0x70, 0x19, 0x84, 0x1f, 0x8e, 0xe9, 0x61,
	0xe5, 0x52, 0x3, 0x96, 0xea, 0xd8, 0xb6, 0x3,  0x9f, 0xc4, 0x3e, 0x23, 0x77, 0x17, 0x54, 0xfb,
	0x13, 0xf0, 0x3e, 0x9a, 0x27, 0x5d, 0x12, 0x99, 0x58, 0x8d, 0x41, 0x46, 0xd9, 0xc9, 0x29, 0xbd,
	0x40, 0xd1, 0x4f, 0xef, 0x63, 0x7b, 0x54, 0xe6, 0x59, 0x6d, 0xe2, 0x30, 0xe8, 0x2c, 0x2f, 0xf9,
	0x66, 0xa2, 0x12, 0xf5, 0x58, 0x61, 0xac, 0x43, 0xec, 0x7e, 0xf9, 0x2e, 0x27, 0x70, 0x35, 0x75,
	0xb4, 0x10, 0x29, 0xac, 0x0a, 0xab, 0x59, 0xb6, 0x68, 0x4c, 0x16, 0xaf, 0xf0, 0x4f, 0x21, 0xcd,
	0xcc, 0x48, 0x97, 0xe4, 0x21, 0x65, 0xa6, 0x55, 0xb8, 0xf3, 0xb2, 0x7b, 0x91, 0xd7, 0xca, 0xb9,
	0x17, 0x58, 0x31, 0x71, 0xc0, 0xc9, 0x69, 0x1e, 0xf0, 0x9e, 0x3f, 0xe2, 0x37, 0x4,  0x2d, 0xa8,
	0x55, 0x9,  0x6b, 0x9c, 0xc6, 0x37, 0xa9, 0x9b, 0xdf, 0x67, 0x73, 0x7b, 0x46, 0xf9, 0x63, 0x47,
	0xcb, 0xa0, 0x57, 0x2a, 0xed, 0x97, 0x2f, 0xfe, 0x92, 0xf2, 0x20, 0x2c, 0x7e, 0xee, 0x7d, 0x11,
	0x78, 0xe6, 0xb9, 0x9,  0xd1, 0x94, 0xce, 0xd1, 0x5b, 0xf4, 0x44, 0xa9, 0xcb, 0x26, 0x2,  0x36,
	0x57, 0x2c, 0xa2, 0xbe, 0x37, 0xde, 0x86, 0x46, 0x20, 0x27, 0x9d, 0xa0, 0x2f, 0x4,  0xc1, 0xcd,
	0xff, 0x81, 0xe5, 0xe6, 0x2c, 0x9e, 0x39, 0x82, 0x31, 0x54, 0x33, 0xf8, 0xe7, 0xa0, 0xe5, 0x96,
	0xa4, 0x40, 0xc4, 0x44, 0xfe, 0x93, 0x66, 0xe2, 0xda, 0xaa, 0xb8, 0xfb, 0x2f, 0x3b, 0x8c, 0xce,
	0xaf, 0xd4, 0xf6, 0x45, 0x63, 0x21, 0x8d, 0x98, 0xc4, 0xab, 0x18, 0xd7, 0x2b, 0x3c, 0x1d, 0xde,
	0xe7, 0x1f, 0xe1, 0xc5, 0x79, 0x57, 0x60, 0x20, 0xfa, 0x99, 0xbd, 0x7b, 0xa2, 0x94, 0x0b, 0xa3,
	0xb4, 0xb3, 0x33, 0x4a, 0x2f, 0xd0, 0x17, 0x7,  0x2e, 0x70, 0x19, 0x84, 0x1f, 0x8e, 0xe9, 0x61,
	0xe5, 0x52, 0x3, 0x96, 0xea, 0xd8, 0xb6, 0x3,  0x9f, 0xc4, 0x3e, 0x23, 0x77, 0x17, 0x54, 0xfb,
	0x13, 0xf0, 0x3e, 0x9a, 0x27, 0x5d, 0x12, 0x99, 0x58, 0x8d, 0x41, 0x46, 0xd9, 0xc9, 0x29, 0xbd,
	0x40, 0xd1, 0x4f, 0xef, 0x63, 0x7b, 0x54, 0xe6, 0x59, 0x6d, 0xe2, 0x30, 0xe8, 0x2c, 0x2f, 0xf9,
	0x66, 0xa2, 0x12, 0xf5, 0x58, 0x61, 0xac, 0x43, 0xec, 0x7e, 0xf9, 0x2e, 0x27, 0x70, 0x35, 0x75,
	0xb4, 0x10, 0x29, 0xac, 0x0a, 0xab, 0x59, 0xb6, 0x68, 0x4c, 0x16, 0xaf, 0xf0, 0x4f, 0x21, 0xcd,
};

char dh_p_4096[] = {
	0xce, 0x58, 0xe8, 0x62, 0xc8, 0xd2, 0xb5, 0x45, 0x1f, 0xa5, 0xc3, 0xdb, 0x8e, 0x69, 0x42, 0xd2,
	0x21, 0x7e, 0x6b, 0x26, 0x69, 0x45, 0xf1, 0x33, 0xcf, 0xd7, 0xe6, 0x6e, 0x64, 0xc3, 0x29, 0xa5,
	0x68, 0x49, 0x3d, 0x13, 0x0b, 0x42, 0x36, 0xa6, 0xf4, 0xb1, 0xab, 0xa3, 0x8f, 0xe6, 0xcf, 0x46,
	0xe8, 0x85, 0xf3, 0xaa, 0xcb, 0x09, 0x84, 0x32, 0x34, 0xf7, 0x46, 0x0a, 0x65, 0xf9, 0xb5, 0x97,
	0xc2, 0x4a, 0x6f, 0x41, 0x40, 0xc9, 0x9e, 0x63, 0xe1, 0x0f, 0xd2, 0x12, 0x59, 0x35, 0xcc, 0x39,
	0x99, 0x04, 0xe8, 0x9a, 0xd2, 0x00, 0x7a, 0xce, 0x3c, 0x78, 0xfe, 0xea, 0x4b, 0x13, 0x53, 0xcd,
	0xc3, 0x60, 0x73, 0xa4, 0x3f, 0xbc, 0x8a, 0x8d, 0x61, 0x1c, 0xfa, 0xaf, 0xb7, 0xf8, 0x37, 0xa5,
	0xe2, 0x3a, 0xd2, 0x7a, 0xb6, 0x00, 0xf3, 0xd8, 0x3a, 0xa2, 0x46, 0xd2, 0x5c, 0x91, 0xc1, 0x05,
	0x6a, 0xf3, 0x2c, 0xd2, 0x2d, 0x55, 0xc1, 0x54, 0x40, 0x18, 0x71, 0x07, 0x96, 0xa9, 0x56, 0x6e,
	0x45, 0x58, 0x24, 0xce, 0x75, 0x80, 0x3,  0x68, 0x36, 0x96, 0x03, 0xb2, 0x9c, 0x25, 0xbc, 0x55,
	0x0d, 0xe8, 0xa1, 0x7d, 0xdd, 0x39, 0x87, 0x3c, 0xa1, 0x6a, 0xeb, 0x1b, 0x4f, 0x14, 0x72, 0x88,
	0x6c, 0x14, 0x6d, 0x24, 0xb7, 0xda, 0xf8, 0x97, 0xaa, 0xba, 0xb4, 0xdd, 0xc9, 0x5b, 0x28, 0x10,
	0x49, 0xfa, 0x93, 0xcc, 0x62, 0xc0, 0x70, 0xf8, 0xd6, 0xdc, 0xb2, 0x80, 0x35, 0x20, 0x84, 0xa4,
	0x99, 0xfc, 0x10, 0x7c, 0x9d, 0xc0, 0xc6, 0xd4, 0x8b, 0x0c, 0x57, 0xf1, 0x01, 0xf5, 0x1a, 0x4f,
	0x20, 0xfa, 0x8d, 0x66, 0x8b, 0x22, 0x3c, 0x96, 0xef, 0xd0, 0xde, 0xe5, 0x7e, 0x7f, 0x23, 0xdc,
	0x6d, 0x71, 0xdf, 0xc3, 0xe5, 0x1b, 0x39, 0xfe, 0xb7, 0x77, 0xe5, 0x72, 0x0d, 0x1c, 0x8d, 0xb7,
	0xce, 0x58, 0xe8, 0x62, 0xc8, 0xd2, 0xb5, 0x45, 0x1f, 0xa5, 0xc3, 0xdb, 0x8e, 0x69, 0x42, 0xd2,
	0x21, 0x7e, 0x6b, 0x26, 0x69, 0x45, 0xf1, 0x33, 0xcf, 0xd7, 0xe6, 0x6e, 0x64, 0xc3, 0x29, 0xa5,
	0x68, 0x49, 0x3d, 0x13, 0x0b, 0x42, 0x36, 0xa6, 0xf4, 0xb1, 0xab, 0xa3, 0x8f, 0xe6, 0xcf, 0x46,
	0xe8, 0x85, 0xf3, 0xaa, 0xcb, 0x09, 0x84, 0x32, 0x34, 0xf7, 0x46, 0x0a, 0x65, 0xf9, 0xb5, 0x97,
	0xc2, 0x4a, 0x6f, 0x41, 0x40, 0xc9, 0x9e, 0x63, 0xe1, 0x0f, 0xd2, 0x12, 0x59, 0x35, 0xcc, 0x39,
	0x99, 0x04, 0xe8, 0x9a, 0xd2, 0x00, 0x7a, 0xce, 0x3c, 0x78, 0xfe, 0xea, 0x4b, 0x13, 0x53, 0xcd,
	0xc3, 0x60, 0x73, 0xa4, 0x3f, 0xbc, 0x8a, 0x8d, 0x61, 0x1c, 0xfa, 0xaf, 0xb7, 0xf8, 0x37, 0xa5,
	0xe2, 0x3a, 0xd2, 0x7a, 0xb6, 0x00, 0xf3, 0xd8, 0x3a, 0xa2, 0x46, 0xd2, 0x5c, 0x91, 0xc1, 0x05,
	0x6a, 0xf3, 0x2c, 0xd2, 0x2d, 0x55, 0xc1, 0x54, 0x40, 0x18, 0x71, 0x07, 0x96, 0xa9, 0x56, 0x6e,
	0x45, 0x58, 0x24, 0xce, 0x75, 0x80, 0x3,  0x68, 0x36, 0x96, 0x03, 0xb2, 0x9c, 0x25, 0xbc, 0x55,
	0x0d, 0xe8, 0xa1, 0x7d, 0xdd, 0x39, 0x87, 0x3c, 0xa1, 0x6a, 0xeb, 0x1b, 0x4f, 0x14, 0x72, 0x88,
	0x6c, 0x14, 0x6d, 0x24, 0xb7, 0xda, 0xf8, 0x97, 0xaa, 0xba, 0xb4, 0xdd, 0xc9, 0x5b, 0x28, 0x10,
	0x49, 0xfa, 0x93, 0xcc, 0x62, 0xc0, 0x70, 0xf8, 0xd6, 0xdc, 0xb2, 0x80, 0x35, 0x20, 0x84, 0xa4,
	0x99, 0xfc, 0x10, 0x7c, 0x9d, 0xc0, 0xc6, 0xd4, 0x8b, 0x0c, 0x57, 0xf1, 0x01, 0xf5, 0x1a, 0x4f,
	0x20, 0xfa, 0x8d, 0x66, 0x8b, 0x22, 0x3c, 0x96, 0xef, 0xd0, 0xde, 0xe5, 0x7e, 0x7f, 0x23, 0xdc,
	0x6d, 0x71, 0xdf, 0xc3, 0xe5, 0x1b, 0x39, 0xfe, 0xb7, 0x77, 0xe5, 0x72, 0x0d, 0x1c, 0x8d, 0xb7
};

char dh_xa_4096[] = {
	0x6b, 0x1f, 0xc4, 0x85, 0x98, 0xc3, 0x01, 0xda, 0x39, 0xf0, 0x1b, 0x76, 0x5d, 0x81, 0x1d, 0x1f,
	0xc9, 0x93, 0x95, 0xc1, 0xf8, 0xd1, 0x67, 0x2c, 0xd4, 0x0a, 0x67, 0xf0, 0x40, 0x86, 0x82, 0x7f,
	0x8f, 0x9d, 0x79, 0x04, 0xee, 0x4a, 0x54, 0xc9, 0x9c, 0x7f, 0xda, 0x15, 0x13, 0xc6, 0x95, 0xfb,
	0xfc, 0x7b, 0xe7, 0xd8, 0xde, 0x2a, 0xd8, 0xfd, 0xff, 0xdb, 0xa4, 0x7f, 0x4b, 0x37, 0x5d, 0x42,
	0xb6, 0x46, 0x4c, 0xbc, 0x34, 0x23, 0x99, 0x74, 0xf8, 0x80, 0x1b, 0xc1, 0x97, 0x34, 0xdf, 0x23,
	0x15, 0xa2, 0x8b, 0xec, 0xf3, 0x3e, 0x20, 0x93, 0x63, 0x88, 0x17, 0x70, 0x75, 0xbb, 0x9d, 0xb8,
	0x32, 0xb0, 0xae, 0xb5, 0x24, 0x6a, 0x86, 0xf6, 0xc1, 0x60, 0x41, 0xc4, 0xf4, 0x95, 0x6e, 0x10,
	0x2f, 0xd8, 0x58, 0x56, 0x42, 0x82, 0x71, 0x85, 0x19, 0xde, 0x91, 0xf0, 0x2f, 0x30, 0x0c, 0x63,
	0x0f, 0x2a, 0x77, 0x25, 0x4b, 0xb3, 0xd3, 0x2d, 0xfd, 0x94, 0x8b, 0x53, 0x02, 0x21, 0x40, 0xd7,
	0x36, 0x76, 0xf3, 0xc8, 0xc0, 0x36, 0x3d, 0x23, 0xc9, 0xbd, 0x92, 0x51, 0xf2, 0x4b, 0x83, 0x15,
	0xe0, 0x80, 0x86, 0x24, 0xe2, 0x20, 0x35, 0x97, 0xda, 0x0e, 0x68, 0x39, 0x01, 0xdd, 0x01, 0x87,
	0xa2, 0x47, 0xd2, 0x0d, 0xee, 0xfe, 0xdc, 0x5a, 0x37, 0x23, 0xeb, 0x3d, 0xe8, 0x1e, 0x39, 0x2d,
	0xbf, 0xa6, 0xe9, 0x17, 0x48, 0xe2, 0xea, 0xef, 0x1d, 0x2f, 0xe2, 0xaf, 0x3c, 0xbc, 0xae, 0xa7,
	0x42, 0x9b, 0xa5, 0x7d, 0x47, 0x8a, 0x20, 0xc5, 0xae, 0xa1, 0xe4, 0xe8, 0x1c, 0x05, 0xc0, 0x0a,
	0x05, 0xdc, 0x01, 0x74, 0xde, 0xad, 0xad, 0x07, 0xec, 0x6e, 0x6a, 0xc7, 0xee, 0x0f, 0xb8, 0xbe,
	0xaa, 0x46, 0x61, 0x8c, 0x12, 0x5a, 0xaf, 0x05, 0xff, 0x1b, 0x35, 0x6b, 0xe2, 0x3d, 0x48, 0x4f,
	0x6b, 0x1f, 0xc4, 0x85, 0x98, 0xc3, 0x01, 0xda, 0x39, 0xf0, 0x1b, 0x76, 0x5d, 0x81, 0x1d, 0x1f,
	0xc9, 0x93, 0x95, 0xc1, 0xf8, 0xd1, 0x67, 0x2c, 0xd4, 0x0a, 0x67, 0xf0, 0x40, 0x86, 0x82, 0x7f,
	0x8f, 0x9d, 0x79, 0x04, 0xee, 0x4a, 0x54, 0xc9, 0x9c, 0x7f, 0xda, 0x15, 0x13, 0xc6, 0x95, 0xfb,
	0xfc, 0x7b, 0xe7, 0xd8, 0xde, 0x2a, 0xd8, 0xfd, 0xff, 0xdb, 0xa4, 0x7f, 0x4b, 0x37, 0x5d, 0x42,
	0xb6, 0x46, 0x4c, 0xbc, 0x34, 0x23, 0x99, 0x74, 0xf8, 0x80, 0x1b, 0xc1, 0x97, 0x34, 0xdf, 0x23,
	0x15, 0xa2, 0x8b, 0xec, 0xf3, 0x3e, 0x20, 0x93, 0x63, 0x88, 0x17, 0x70, 0x75, 0xbb, 0x9d, 0xb8,
	0x32, 0xb0, 0xae, 0xb5, 0x24, 0x6a, 0x86, 0xf6, 0xc1, 0x60, 0x41, 0xc4, 0xf4, 0x95, 0x6e, 0x10,
	0x2f, 0xd8, 0x58, 0x56, 0x42, 0x82, 0x71, 0x85, 0x19, 0xde, 0x91, 0xf0, 0x2f, 0x30, 0x0c, 0x63,
	0x0f, 0x2a, 0x77, 0x25, 0x4b, 0xb3, 0xd3, 0x2d, 0xfd, 0x94, 0x8b, 0x53, 0x02, 0x21, 0x40, 0xd7,
	0x36, 0x76, 0xf3, 0xc8, 0xc0, 0x36, 0x3d, 0x23, 0xc9, 0xbd, 0x92, 0x51, 0xf2, 0x4b, 0x83, 0x15,
	0xe0, 0x80, 0x86, 0x24, 0xe2, 0x20, 0x35, 0x97, 0xda, 0x0e, 0x68, 0x39, 0x01, 0xdd, 0x01, 0x87,
	0xa2, 0x47, 0xd2, 0x0d, 0xee, 0xfe, 0xdc, 0x5a, 0x37, 0x23, 0xeb, 0x3d, 0xe8, 0x1e, 0x39, 0x2d,
	0xbf, 0xa6, 0xe9, 0x17, 0x48, 0xe2, 0xea, 0xef, 0x1d, 0x2f, 0xe2, 0xaf, 0x3c, 0xbc, 0xae, 0xa7,
	0x42, 0x9b, 0xa5, 0x7d, 0x47, 0x8a, 0x20, 0xc5, 0xae, 0xa1, 0xe4, 0xe8, 0x1c, 0x05, 0xc0, 0x0a,
	0x05, 0xdc, 0x01, 0x74, 0xde, 0xad, 0xad, 0x07, 0xec, 0x6e, 0x6a, 0xc7, 0xee, 0x0f, 0xb8, 0xbe,
	0xaa, 0x46, 0x61, 0x8c, 0x12, 0x5a, 0xaf, 0x05, 0xff, 0x1b, 0x35, 0x6b, 0xe2, 0x3d, 0x48, 0x4f
};

char dh_xb_4096[] = {
	0x5c, 0xdf, 0x3, 0x2f, 0x18, 0xac, 0xbc, 0xeb, 0x95, 0xa2, 0x33, 0x70, 0x39, 0x13, 0x92, 0x7e,
	0x91, 0x19, 0x89, 0xd4, 0x0,  0xd1, 0xc5, 0x7e, 0x32, 0xb7, 0x4a, 0xd2, 0xff, 0x11, 0x7a, 0x9b,
	0x2,  0x84, 0xd0, 0x8e, 0x19, 0x91, 0x34, 0xc2, 0x5,  0xff, 0xe4, 0xf4, 0xd8, 0xcf, 0xc8, 0xa0,
	0xeb, 0x19, 0xb9, 0x69, 0x60, 0xcd, 0xa8, 0xda, 0x33, 0xbc, 0xa7, 0x80, 0x0,  0x92, 0x27, 0xe0,
	0xe7, 0x34, 0x77, 0x1f, 0xfd, 0x56, 0x0,  0x0c, 0x57, 0x0,  0x6d, 0x47, 0xe4, 0x32, 0xd7, 0x22,
	0x64, 0xa5, 0x33, 0x65, 0x33, 0x3e, 0x7c, 0x4e, 0x9d, 0xa6, 0xb7, 0x8b, 0xd7, 0xaa, 0x72, 0xe5,
	0x9d, 0xd5, 0xb4, 0x25, 0xcb, 0x30, 0x2,  0xfc, 0xb5, 0xae, 0xb3, 0x88, 0x67, 0x55, 0x0a, 0x7e,
	0x9d, 0xe8, 0x32, 0xfb, 0x50, 0x79, 0x4e, 0x9b, 0x21, 0x92, 0x25, 0x3,  0xa0, 0x15, 0x52, 0x3d,
	0x5e, 0x21, 0x0a, 0x9e, 0x3,  0xdd, 0x3f, 0xcc, 0x38, 0xf6, 0xa9, 0xa6, 0xf8, 0xfd, 0x15, 0x7d,
	0x67, 0x4e, 0x14, 0xae, 0x4d, 0xe2, 0x1f, 0x78, 0x77, 0xfb, 0x83, 0x5f, 0x48, 0xa8, 0xc8, 0x21,
	0x8b, 0xd9, 0xf8, 0x14, 0xe6, 0x42, 0x95, 0xbd, 0x9a, 0x96, 0xbe, 0xf4, 0x7d, 0x26, 0x5d, 0xa1,
	0x81, 0x9b, 0x1c, 0xec, 0xfe, 0xce, 0x9,  0x1d, 0xb7, 0x7a, 0xba, 0xca, 0x7f, 0x54, 0xee, 0x36,
	0x54, 0x65, 0x4a, 0xd0, 0x5c, 0x84, 0x8c, 0x3e, 0x1b, 0xfe, 0x91, 0x6f, 0x95, 0xb5, 0x76, 0xbf,
	0x61, 0x2a, 0x7, 0x23, 0x86, 0xb9, 0xe0, 0x19, 0x29, 0xcf, 0xea, 0x3a, 0x1,  0xbf, 0xee, 0x1b,
	0x5e, 0x3c, 0x4, 0xff, 0x1d, 0xcf, 0xa6, 0x56, 0xb3, 0x22, 0xbb, 0x45, 0x4b, 0x7f, 0x83, 0x87,
	0xef, 0x21, 0x5, 0xf7, 0x38, 0x1f, 0x6,  0x4d, 0x71, 0x0b, 0xe3, 0xe1, 0xb7, 0x7e, 0xae, 0x18,
	0x5c, 0xdf, 0x3, 0x2f, 0x18, 0xac, 0xbc, 0xeb, 0x95, 0xa2, 0x33, 0x70, 0x39, 0x13, 0x92, 0x7e,
	0x91, 0x19, 0x89, 0xd4, 0x0,  0xd1, 0xc5, 0x7e, 0x32, 0xb7, 0x4a, 0xd2, 0xff, 0x11, 0x7a, 0x9b,
	0x2,  0x84, 0xd0, 0x8e, 0x19, 0x91, 0x34, 0xc2, 0x5,  0xff, 0xe4, 0xf4, 0xd8, 0xcf, 0xc8, 0xa0,
	0xeb, 0x19, 0xb9, 0x69, 0x60, 0xcd, 0xa8, 0xda, 0x33, 0xbc, 0xa7, 0x80, 0x0,  0x92, 0x27, 0xe0,
	0xe7, 0x34, 0x77, 0x1f, 0xfd, 0x56, 0x0,  0x0c, 0x57, 0x0,  0x6d, 0x47, 0xe4, 0x32, 0xd7, 0x22,
	0x64, 0xa5, 0x33, 0x65, 0x33, 0x3e, 0x7c, 0x4e, 0x9d, 0xa6, 0xb7, 0x8b, 0xd7, 0xaa, 0x72, 0xe5,
	0x9d, 0xd5, 0xb4, 0x25, 0xcb, 0x30, 0x2,  0xfc, 0xb5, 0xae, 0xb3, 0x88, 0x67, 0x55, 0x0a, 0x7e,
	0x9d, 0xe8, 0x32, 0xfb, 0x50, 0x79, 0x4e, 0x9b, 0x21, 0x92, 0x25, 0x3,  0xa0, 0x15, 0x52, 0x3d,
	0x5e, 0x21, 0x0a, 0x9e, 0x3,  0xdd, 0x3f, 0xcc, 0x38, 0xf6, 0xa9, 0xa6, 0xf8, 0xfd, 0x15, 0x7d,
	0x67, 0x4e, 0x14, 0xae, 0x4d, 0xe2, 0x1f, 0x78, 0x77, 0xfb, 0x83, 0x5f, 0x48, 0xa8, 0xc8, 0x21,
	0x8b, 0xd9, 0xf8, 0x14, 0xe6, 0x42, 0x95, 0xbd, 0x9a, 0x96, 0xbe, 0xf4, 0x7d, 0x26, 0x5d, 0xa1,
	0x81, 0x9b, 0x1c, 0xec, 0xfe, 0xce, 0x9,  0x1d, 0xb7, 0x7a, 0xba, 0xca, 0x7f, 0x54, 0xee, 0x36,
	0x54, 0x65, 0x4a, 0xd0, 0x5c, 0x84, 0x8c, 0x3e, 0x1b, 0xfe, 0x91, 0x6f, 0x95, 0xb5, 0x76, 0xbf,
	0x61, 0x2a, 0x7, 0x23, 0x86, 0xb9, 0xe0, 0x19, 0x29, 0xcf, 0xea, 0x3a, 0x1,  0xbf, 0xee, 0x1b,
	0x5e, 0x3c, 0x4, 0xff, 0x1d, 0xcf, 0xa6, 0x56, 0xb3, 0x22, 0xbb, 0x45, 0x4b, 0x7f, 0x83, 0x87,
	0xef, 0x21, 0x5, 0xf7, 0x38, 0x1f, 0x6,  0x4d, 0x71, 0x0b, 0xe3, 0xe1, 0xb7, 0x7e, 0xae, 0x18
};

char dh_except_a_pubkey_4096[] = {
	0xa5, 0x24, 0x63, 0x20, 0xb2, 0x56, 0x9a, 0x94, 0x97, 0xf7, 0x88, 0x41, 0x35, 0xeb, 0x52, 0x37,
	0xa4, 0xf2, 0x74, 0x1b, 0x38, 0xe4, 0x4c, 0x8b, 0x4b, 0xd2, 0xa5, 0xad, 0xb8, 0x2f, 0x7b, 0x5a,
	0xfd, 0xbc, 0x9c, 0xe0, 0xea, 0x9e, 0x82, 0x3,  0x62, 0xe2, 0xdc, 0x6c, 0x56, 0x9,  0x2,  0x28,
	0xb8, 0x2d, 0xb8, 0x46, 0xaf, 0x3a, 0xf4, 0x51, 0xf7, 0x4d, 0xc4, 0xd9, 0xa9, 0x1d, 0x67, 0x9d,
	0x2b, 0x18, 0x56, 0x86, 0x2a, 0x3,  0x19, 0xe9, 0x6,  0xeb, 0x4a, 0x6f, 0x2a, 0x40, 0x28, 0xbb,
	0x3e, 0x87, 0xc1, 0xce, 0x39, 0x6e, 0x3b, 0x1f, 0xb0, 0x9,  0x33, 0x67, 0x19, 0x0e, 0x1a, 0xb2,
	0xb3, 0x7d, 0xd3, 0xe6, 0x33, 0xf4, 0x7c, 0x82, 0x73, 0x7b, 0xb6, 0x16, 0x55, 0xff, 0x76, 0xaf,
	0x7f, 0xc2, 0x42, 0x51, 0xa9, 0xad, 0x1e, 0x72, 0xc9, 0x63, 0xab, 0x41, 0x5a, 0x26, 0x32, 0x39,
	0x5d, 0xa6, 0x7,  0x56, 0x93, 0x89, 0xe5, 0x0f, 0x2a, 0xb5, 0x67, 0x3a, 0xcf, 0xc3, 0x82, 0x83,
	0xf6, 0x88, 0x52, 0x0b, 0xfc, 0x6a, 0x5b, 0x1a, 0x57, 0x87, 0x86, 0xef, 0xda, 0x47, 0xdb, 0x4d,
	0xba, 0xe7, 0x3,  0x5b, 0xe4, 0x70, 0x8b, 0xe0, 0xe1, 0x92, 0x13, 0x86, 0x74, 0x4,  0xdc, 0x6a,
	0x0a, 0x2a, 0x20, 0xec, 0x6d, 0xbf, 0xf0, 0x46, 0xf7, 0x9,  0x2,  0xdb, 0x2f, 0x70, 0x11, 0xdd,
	0xb0, 0x13, 0xa2, 0xc1, 0x58, 0x74, 0x29, 0x19, 0x8d, 0x4a, 0x94, 0x80, 0x0b, 0xd7, 0x25, 0x85,
	0x10, 0x35, 0x97, 0x48, 0x6e, 0x70, 0x28, 0xae, 0x58, 0x97, 0x7d, 0xf2, 0x19, 0x27, 0x13, 0xab,
	0x47, 0x9b, 0x54, 0xdf, 0xc3, 0x5b, 0x5f, 0x5e, 0xb4, 0x64, 0x47, 0xce, 0x40, 0x3b, 0x0c, 0x4a,
	0x62, 0x52, 0xba, 0xc7, 0xf0, 0x36, 0x87, 0x9c, 0x79, 0x9a, 0x83, 0x11, 0x61, 0x0c, 0x1b, 0x6b,
	0xa5, 0x24, 0x63, 0x20, 0xb2, 0x56, 0x9a, 0x94, 0x97, 0xf7, 0x88, 0x41, 0x35, 0xeb, 0x52, 0x37,
	0xa4, 0xf2, 0x74, 0x1b, 0x38, 0xe4, 0x4c, 0x8b, 0x4b, 0xd2, 0xa5, 0xad, 0xb8, 0x2f, 0x7b, 0x5a,
	0xfd, 0xbc, 0x9c, 0xe0, 0xea, 0x9e, 0x82, 0x3,  0x62, 0xe2, 0xdc, 0x6c, 0x56, 0x9,  0x2,  0x28,
	0xb8, 0x2d, 0xb8, 0x46, 0xaf, 0x3a, 0xf4, 0x51, 0xf7, 0x4d, 0xc4, 0xd9, 0xa9, 0x1d, 0x67, 0x9d,
	0x2b, 0x18, 0x56, 0x86, 0x2a, 0x3,  0x19, 0xe9, 0x6,  0xeb, 0x4a, 0x6f, 0x2a, 0x40, 0x28, 0xbb,
	0x3e, 0x87, 0xc1, 0xce, 0x39, 0x6e, 0x3b, 0x1f, 0xb0, 0x9,  0x33, 0x67, 0x19, 0x0e, 0x1a, 0xb2,
	0xb3, 0x7d, 0xd3, 0xe6, 0x33, 0xf4, 0x7c, 0x82, 0x73, 0x7b, 0xb6, 0x16, 0x55, 0xff, 0x76, 0xaf,
	0x7f, 0xc2, 0x42, 0x51, 0xa9, 0xad, 0x1e, 0x72, 0xc9, 0x63, 0xab, 0x41, 0x5a, 0x26, 0x32, 0x39,
	0x5d, 0xa6, 0x7,  0x56, 0x93, 0x89, 0xe5, 0x0f, 0x2a, 0xb5, 0x67, 0x3a, 0xcf, 0xc3, 0x82, 0x83,
	0xf6, 0x88, 0x52, 0x0b, 0xfc, 0x6a, 0x5b, 0x1a, 0x57, 0x87, 0x86, 0xef, 0xda, 0x47, 0xdb, 0x4d,
	0xba, 0xe7, 0x3,  0x5b, 0xe4, 0x70, 0x8b, 0xe0, 0xe1, 0x92, 0x13, 0x86, 0x74, 0x4,  0xdc, 0x6a,
	0x0a, 0x2a, 0x20, 0xec, 0x6d, 0xbf, 0xf0, 0x46, 0xf7, 0x9,  0x2,  0xdb, 0x2f, 0x70, 0x11, 0xdd,
	0xb0, 0x13, 0xa2, 0xc1, 0x58, 0x74, 0x29, 0x19, 0x8d, 0x4a, 0x94, 0x80, 0x0b, 0xd7, 0x25, 0x85,
	0x10, 0x35, 0x97, 0x48, 0x6e, 0x70, 0x28, 0xae, 0x58, 0x97, 0x7d, 0xf2, 0x19, 0x27, 0x13, 0xab,
	0x47, 0x9b, 0x54, 0xdf, 0xc3, 0x5b, 0x5f, 0x5e, 0xb4, 0x64, 0x47, 0xce, 0x40, 0x3b, 0x0c, 0x4a,
	0x62, 0x52, 0xba, 0xc7, 0xf0, 0x36, 0x87, 0x9c, 0x79, 0x9a, 0x83, 0x11, 0x61, 0x0c, 0x1b, 0x6b
};

char dh_except_b_pubkey_4096[] = {
	0x44, 0x58, 0xe8, 0x62, 0xc8, 0xd2, 0xb5, 0x45, 0x1f, 0xa5, 0xc3, 0xdb, 0x8e, 0x69, 0x42, 0xd2,
	0x21, 0x7e, 0x6b, 0x26, 0x69, 0x45, 0xf1, 0x33, 0xcf, 0xd7, 0xe6, 0x6e, 0x64, 0xc3, 0x29, 0xa5,
	0x68, 0x49, 0x3d, 0x13, 0x0b, 0x42, 0x36, 0xa6, 0xf4, 0xb1, 0xab, 0xa3, 0x8f, 0xe6, 0xcf, 0x46,
	0xe8, 0x85, 0xf3, 0xaa, 0xcb, 0x9,  0x84, 0x32, 0x34, 0xf7, 0x46, 0x0a, 0x65, 0xf9, 0xb5, 0x97,
	0xc2, 0x4a, 0x6f, 0x41, 0x40, 0xc9, 0x9e, 0x63, 0xe1, 0x0f, 0xd2, 0x12, 0x59, 0x35, 0xcc, 0x39,
	0x99, 0x4, 0xe8, 0x9a, 0xd2, 0x0,  0x7a, 0xce, 0x3c, 0x78, 0xfe, 0xea, 0x4b, 0x13, 0x53, 0xcd,
	0xc3, 0x60, 0x73, 0xa4, 0x3f, 0xbc, 0x8a, 0x8d, 0x61, 0x1c, 0xfa, 0xaf, 0xb7, 0xf8, 0x37, 0xa5,
	0xe2, 0x3a, 0xd2, 0x7a, 0xb6, 0x0,  0xf3, 0xd8, 0x3a, 0xa2, 0x46, 0xd2, 0x5c, 0x91, 0xc1, 0x5,
	0x6a, 0xf3, 0x2c, 0xd2, 0x2d, 0x55, 0xc1, 0x54, 0x40, 0x18, 0x71, 0x7,  0x96, 0xa9, 0x56, 0x6e,
	0x45, 0x58, 0x24, 0xce, 0x75, 0x80, 0x3,  0x68, 0x36, 0x96, 0x3,  0xb2, 0x9c, 0x25, 0xbc, 0x55,
	0x0d, 0xe8, 0xa1, 0x7d, 0xdd, 0x39, 0x87, 0x3c, 0xa1, 0x6a, 0xeb, 0x1b, 0x4f, 0x14, 0x72, 0x88,
	0x6c, 0x14, 0x6d, 0x24, 0xb7, 0xda, 0xf8, 0x97, 0xaa, 0xba, 0xb4, 0xdd, 0xc9, 0x5b, 0x28, 0x10,
	0x49, 0xfa, 0x93, 0xcc, 0x62, 0xc0, 0x70, 0xf8, 0xd6, 0xdc, 0xb2, 0x80, 0x35, 0x20, 0x84, 0xa4,
	0x99, 0xfc, 0x10, 0x7c, 0x9d, 0xc0, 0xc6, 0xd4, 0x8b, 0x0c, 0x57, 0xf1, 0x1,  0xf5, 0x1a, 0x4f,
	0x20, 0xfa, 0x8d, 0x66, 0x8b, 0x22, 0x3c, 0x96, 0xef, 0xd0, 0xde, 0xe5, 0x7e, 0x7f, 0x23, 0xdc,
	0x6d, 0x71, 0xdf, 0xc3, 0xe5, 0x1b, 0x39, 0xfe, 0xb7, 0x77, 0xe5, 0x72, 0x0d, 0x1c, 0x8d, 0xb7,
	0x44, 0x58, 0xe8, 0x62, 0xc8, 0xd2, 0xb5, 0x45, 0x1f, 0xa5, 0xc3, 0xdb, 0x8e, 0x69, 0x42, 0xd2,
	0x21, 0x7e, 0x6b, 0x26, 0x69, 0x45, 0xf1, 0x33, 0xcf, 0xd7, 0xe6, 0x6e, 0x64, 0xc3, 0x29, 0xa5,
	0x68, 0x49, 0x3d, 0x13, 0x0b, 0x42, 0x36, 0xa6, 0xf4, 0xb1, 0xab, 0xa3, 0x8f, 0xe6, 0xcf, 0x46,
	0xe8, 0x85, 0xf3, 0xaa, 0xcb, 0x9,  0x84, 0x32, 0x34, 0xf7, 0x46, 0x0a, 0x65, 0xf9, 0xb5, 0x97,
	0xc2, 0x4a, 0x6f, 0x41, 0x40, 0xc9, 0x9e, 0x63, 0xe1, 0x0f, 0xd2, 0x12, 0x59, 0x35, 0xcc, 0x39,
	0x99, 0x4, 0xe8, 0x9a, 0xd2, 0x0,  0x7a, 0xce, 0x3c, 0x78, 0xfe, 0xea, 0x4b, 0x13, 0x53, 0xcd,
	0xc3, 0x60, 0x73, 0xa4, 0x3f, 0xbc, 0x8a, 0x8d, 0x61, 0x1c, 0xfa, 0xaf, 0xb7, 0xf8, 0x37, 0xa5,
	0xe2, 0x3a, 0xd2, 0x7a, 0xb6, 0x0,  0xf3, 0xd8, 0x3a, 0xa2, 0x46, 0xd2, 0x5c, 0x91, 0xc1, 0x5,
	0x6a, 0xf3, 0x2c, 0xd2, 0x2d, 0x55, 0xc1, 0x54, 0x40, 0x18, 0x71, 0x7,  0x96, 0xa9, 0x56, 0x6e,
	0x45, 0x58, 0x24, 0xce, 0x75, 0x80, 0x3,  0x68, 0x36, 0x96, 0x3,  0xb2, 0x9c, 0x25, 0xbc, 0x55,
	0x0d, 0xe8, 0xa1, 0x7d, 0xdd, 0x39, 0x87, 0x3c, 0xa1, 0x6a, 0xeb, 0x1b, 0x4f, 0x14, 0x72, 0x88,
	0x6c, 0x14, 0x6d, 0x24, 0xb7, 0xda, 0xf8, 0x97, 0xaa, 0xba, 0xb4, 0xdd, 0xc9, 0x5b, 0x28, 0x10,
	0x49, 0xfa, 0x93, 0xcc, 0x62, 0xc0, 0x70, 0xf8, 0xd6, 0xdc, 0xb2, 0x80, 0x35, 0x20, 0x84, 0xa4,
	0x99, 0xfc, 0x10, 0x7c, 0x9d, 0xc0, 0xc6, 0xd4, 0x8b, 0x0c, 0x57, 0xf1, 0x1,  0xf5, 0x1a, 0x4f,
	0x20, 0xfa, 0x8d, 0x66, 0x8b, 0x22, 0x3c, 0x96, 0xef, 0xd0, 0xde, 0xe5, 0x7e, 0x7f, 0x23, 0xdc,
	0x6d, 0x71, 0xdf, 0xc3, 0xe5, 0x1b, 0x39, 0xfe, 0xb7, 0x77, 0xe5, 0x72, 0x0d, 0x1c, 0x8d, 0xb7
};

char dh_share_key_4096[] = {
	0xaf, 0xd4, 0xf6, 0x45, 0x63, 0x21, 0x8d, 0x98, 0xc4, 0xab, 0x18, 0xd7, 0x2b, 0x3c, 0x1d, 0xde,
	0xe7, 0x1f, 0xe1, 0xc5, 0x79, 0x57, 0x60, 0x20, 0xfa, 0x99, 0xbd, 0x7b, 0xa2, 0x94, 0x0b, 0xa3,
	0xb4, 0xb3, 0x33, 0x4a, 0x2f, 0xd0, 0x17, 0x7,  0x2e, 0x70, 0x19, 0x84, 0x1f, 0x8e, 0xe9, 0x61,
	0xe5, 0x52, 0x3, 0x96, 0xea, 0xd8, 0xb6, 0x3,  0x9f, 0xc4, 0x3e, 0x23, 0x77, 0x17, 0x54, 0xfb,
	0x13, 0xf0, 0x3e, 0x9a, 0x27, 0x5d, 0x12, 0x99, 0x58, 0x8d, 0x41, 0x46, 0xd9, 0xc9, 0x29, 0xbd,
	0x40, 0xd1, 0x4f, 0xef, 0x63, 0x7b, 0x54, 0xe6, 0x59, 0x6d, 0xe2, 0x30, 0xe8, 0x2c, 0x2f, 0xf9,
	0x66, 0xa2, 0x12, 0xf5, 0x58, 0x61, 0xac, 0x43, 0xec, 0x7e, 0xf9, 0x2e, 0x27, 0x70, 0x35, 0x75,
	0xb4, 0x10, 0x29, 0xac, 0x0a, 0xab, 0x59, 0xb6, 0x68, 0x4c, 0x16, 0xaf, 0xf0, 0x4f, 0x21, 0xcd,
	0xcc, 0x48, 0x97, 0xe4, 0x21, 0x65, 0xa6, 0x55, 0xb8, 0xf3, 0xb2, 0x7b, 0x91, 0xd7, 0xca, 0xb9,
	0x17, 0x58, 0x31, 0x71, 0xc0, 0xc9, 0x69, 0x1e, 0xf0, 0x9e, 0x3f, 0xe2, 0x37, 0x4,  0x2d, 0xa8,
	0x55, 0x9,  0x6b, 0x9c, 0xc6, 0x37, 0xa9, 0x9b, 0xdf, 0x67, 0x73, 0x7b, 0x46, 0xf9, 0x63, 0x47,
	0xcb, 0xa0, 0x57, 0x2a, 0xed, 0x97, 0x2f, 0xfe, 0x92, 0xf2, 0x20, 0x2c, 0x7e, 0xee, 0x7d, 0x11,
	0x78, 0xe6, 0xb9, 0x9,  0xd1, 0x94, 0xce, 0xd1, 0x5b, 0xf4, 0x44, 0xa9, 0xcb, 0x26, 0x2,  0x36,
	0x57, 0x2c, 0xa2, 0xbe, 0x37, 0xde, 0x86, 0x46, 0x20, 0x27, 0x9d, 0xa0, 0x2f, 0x4,  0xc1, 0xcd,
	0xff, 0x81, 0xe5, 0xe6, 0x2c, 0x9e, 0x39, 0x82, 0x31, 0x54, 0x33, 0xf8, 0xe7, 0xa0, 0xe5, 0x96,
	0xa4, 0x40, 0xc4, 0x44, 0xfe, 0x93, 0x66, 0xe2, 0xda, 0xaa, 0xb8, 0xfb, 0x2f, 0x3b, 0x8c, 0xce,
	0xaf, 0xd4, 0xf6, 0x45, 0x63, 0x21, 0x8d, 0x98, 0xc4, 0xab, 0x18, 0xd7, 0x2b, 0x3c, 0x1d, 0xde,
	0xe7, 0x1f, 0xe1, 0xc5, 0x79, 0x57, 0x60, 0x20, 0xfa, 0x99, 0xbd, 0x7b, 0xa2, 0x94, 0x0b, 0xa3,
	0xb4, 0xb3, 0x33, 0x4a, 0x2f, 0xd0, 0x17, 0x7,  0x2e, 0x70, 0x19, 0x84, 0x1f, 0x8e, 0xe9, 0x61,
	0xe5, 0x52, 0x3, 0x96, 0xea, 0xd8, 0xb6, 0x3,  0x9f, 0xc4, 0x3e, 0x23, 0x77, 0x17, 0x54, 0xfb,
	0x13, 0xf0, 0x3e, 0x9a, 0x27, 0x5d, 0x12, 0x99, 0x58, 0x8d, 0x41, 0x46, 0xd9, 0xc9, 0x29, 0xbd,
	0x40, 0xd1, 0x4f, 0xef, 0x63, 0x7b, 0x54, 0xe6, 0x59, 0x6d, 0xe2, 0x30, 0xe8, 0x2c, 0x2f, 0xf9,
	0x66, 0xa2, 0x12, 0xf5, 0x58, 0x61, 0xac, 0x43, 0xec, 0x7e, 0xf9, 0x2e, 0x27, 0x70, 0x35, 0x75,
	0xb4, 0x10, 0x29, 0xac, 0x0a, 0xab, 0x59, 0xb6, 0x68, 0x4c, 0x16, 0xaf, 0xf0, 0x4f, 0x21, 0xcd,
	0xcc, 0x48, 0x97, 0xe4, 0x21, 0x65, 0xa6, 0x55, 0xb8, 0xf3, 0xb2, 0x7b, 0x91, 0xd7, 0xca, 0xb9,
	0x17, 0x58, 0x31, 0x71, 0xc0, 0xc9, 0x69, 0x1e, 0xf0, 0x9e, 0x3f, 0xe2, 0x37, 0x4,  0x2d, 0xa8,
	0x55, 0x9,  0x6b, 0x9c, 0xc6, 0x37, 0xa9, 0x9b, 0xdf, 0x67, 0x73, 0x7b, 0x46, 0xf9, 0x63, 0x47,
	0xcb, 0xa0, 0x57, 0x2a, 0xed, 0x97, 0x2f, 0xfe, 0x92, 0xf2, 0x20, 0x2c, 0x7e, 0xee, 0x7d, 0x11,
	0x78, 0xe6, 0xb9, 0x9,  0xd1, 0x94, 0xce, 0xd1, 0x5b, 0xf4, 0x44, 0xa9, 0xcb, 0x26, 0x2,  0x36,
	0x57, 0x2c, 0xa2, 0xbe, 0x37, 0xde, 0x86, 0x46, 0x20, 0x27, 0x9d, 0xa0, 0x2f, 0x4,  0xc1, 0xcd,
	0xff, 0x81, 0xe5, 0xe6, 0x2c, 0x9e, 0x39, 0x82, 0x31, 0x54, 0x33, 0xf8, 0xe7, 0xa0, 0xe5, 0x96,
	0xa4, 0x40, 0xc4, 0x44, 0xfe, 0x93, 0x66, 0xe2, 0xda, 0xaa, 0xb8, 0xfb, 0x2f, 0x3b, 0x8c, 0xce,
};



char rsa_e_2048[] = {
	0xaf, 0xd4, 0xf6, 0x45, 0x63, 0x21, 0x8d, 0x98, 0xc4, 0xab, 0x18, 0xd7, 0x2b, 0x3c, 0x1d, 0xde,
	0xe7, 0x1f, 0xe1, 0xc5, 0x79, 0x57, 0x60, 0x20, 0xfa, 0x99, 0xbd, 0x7b, 0xa2, 0x94, 0x0b, 0xa3,
	0xb4, 0xb3, 0x33, 0x4a, 0x2f, 0xd0, 0x17, 0x7,  0x2e, 0x70, 0x19, 0x84, 0x1f, 0x8e, 0xe9, 0x61,
	0xe5, 0x52, 0x3, 0x96, 0xea, 0xd8, 0xb6, 0x3,  0x9f, 0xc4, 0x3e, 0x23, 0x77, 0x17, 0x54, 0xfb,
	0x13, 0xf0, 0x3e, 0x9a, 0x27, 0x5d, 0x12, 0x99, 0x58, 0x8d, 0x41, 0x46, 0xd9, 0xc9, 0x29, 0xbd,
	0x40, 0xd1, 0x4f, 0xef, 0x63, 0x7b, 0x54, 0xe6, 0x59, 0x6d, 0xe2, 0x30, 0xe8, 0x2c, 0x2f, 0xf9,
	0x66, 0xa2, 0x12, 0xf5, 0x58, 0x61, 0xac, 0x43, 0xec, 0x7e, 0xf9, 0x2e, 0x27, 0x70, 0x35, 0x75,
	0xb4, 0x10, 0x29, 0xac, 0x0a, 0xab, 0x59, 0xb6, 0x68, 0x4c, 0x16, 0xaf, 0xf0, 0x4f, 0x21, 0xcd,
	0xcc, 0x48, 0x97, 0xe4, 0x21, 0x65, 0xa6, 0x55, 0xb8, 0xf3, 0xb2, 0x7b, 0x91, 0xd7, 0xca, 0xb9,
	0x17, 0x58, 0x31, 0x71, 0xc0, 0xc9, 0x69, 0x1e, 0xf0, 0x9e, 0x3f, 0xe2, 0x37, 0x4,  0x2d, 0xa8,
	0x55, 0x09, 0x6b, 0x9c, 0xc6, 0x37, 0xa9, 0x9b, 0xdf, 0x67, 0x73, 0x7b, 0x46, 0xf9, 0x63, 0x47,
	0xcb, 0xa0, 0x57, 0x2a, 0xed, 0x97, 0x2f, 0xfe, 0x92, 0xf2, 0x20, 0x2c, 0x7e, 0xee, 0x7d, 0x11,
	0x78, 0xe6, 0xb9, 0x9,  0xd1, 0x94, 0xce, 0xd1, 0x5b, 0xf4, 0x44, 0xa9, 0xcb, 0x26, 0x2,  0x36,
	0x57, 0x2c, 0xa2, 0xbe, 0x37, 0xde, 0x86, 0x46, 0x20, 0x27, 0x9d, 0xa0, 0x2f, 0x4,  0xc1, 0xcd,
	0xff, 0x81, 0xe5, 0xe6, 0x2c, 0x9e, 0x39, 0x82, 0x31, 0x54, 0x33, 0xf8, 0xe7, 0xa0, 0xe5, 0x96,
	0xa4, 0x40, 0xc4, 0x44, 0xfe, 0x93, 0x66, 0xe2, 0xda, 0xaa, 0xb8, 0xfb, 0x2f, 0x3b, 0x8c, 0xce,
};

char rsa_p_2048[] = {
	0xce, 0x58, 0xe8, 0x62, 0xc8, 0xd2, 0xb5, 0x45, 0x1f, 0xa5, 0xc3, 0xdb, 0x8e, 0x69, 0x42, 0xd2,
	0x21, 0x7e, 0x6b, 0x26, 0x69, 0x45, 0xf1, 0x33, 0xcf, 0xd7, 0xe6, 0x6e, 0x64, 0xc3, 0x29, 0xa5,
	0x68, 0x49, 0x3d, 0x13, 0x0b, 0x42, 0x36, 0xa6, 0xf4, 0xb1, 0xab, 0xa3, 0x8f, 0xe6, 0xcf, 0x46,
	0xe8, 0x85, 0xf3, 0xaa, 0xcb, 0x09, 0x84, 0x32, 0x34, 0xf7, 0x46, 0x0a, 0x65, 0xf9, 0xb5, 0x97,
	0xc2, 0x4a, 0x6f, 0x41, 0x40, 0xc9, 0x9e, 0x63, 0xe1, 0x0f, 0xd2, 0x12, 0x59, 0x35, 0xcc, 0x39,
	0x99, 0x04, 0xe8, 0x9a, 0xd2, 0x00, 0x7a, 0xce, 0x3c, 0x78, 0xfe, 0xea, 0x4b, 0x13, 0x53, 0xcd,
	0xc3, 0x60, 0x73, 0xa4, 0x3f, 0xbc, 0x8a, 0x8d, 0x61, 0x1c, 0xfa, 0xaf, 0xb7, 0xf8, 0x37, 0xa5,
	0xe2, 0x3a, 0xd2, 0x7a, 0xb6, 0x00, 0xf3, 0xd8, 0x3a, 0xa2, 0x46, 0xd2, 0x5c, 0x91, 0xc1, 0x05,
	0x6a, 0xf3, 0x2c, 0xd2, 0x2d, 0x55, 0xc1, 0x54, 0x40, 0x18, 0x71, 0x07, 0x96, 0xa9, 0x56, 0x6e,
	0x45, 0x58, 0x24, 0xce, 0x75, 0x80, 0x3,  0x68, 0x36, 0x96, 0x03, 0xb2, 0x9c, 0x25, 0xbc, 0x55,
	0x0d, 0xe8, 0xa1, 0x7d, 0xdd, 0x39, 0x87, 0x3c, 0xa1, 0x6a, 0xeb, 0x1b, 0x4f, 0x14, 0x72, 0x88,
	0x6c, 0x14, 0x6d, 0x24, 0xb7, 0xda, 0xf8, 0x97, 0xaa, 0xba, 0xb4, 0xdd, 0xc9, 0x5b, 0x28, 0x10,
	0x49, 0xfa, 0x93, 0xcc, 0x62, 0xc0, 0x70, 0xf8, 0xd6, 0xdc, 0xb2, 0x80, 0x35, 0x20, 0x84, 0xa4,
	0x99, 0xfc, 0x10, 0x7c, 0x9d, 0xc0, 0xc6, 0xd4, 0x8b, 0x0c, 0x57, 0xf1, 0x01, 0xf5, 0x1a, 0x4f,
	0x20, 0xfa, 0x8d, 0x66, 0x8b, 0x22, 0x3c, 0x96, 0xef, 0xd0, 0xde, 0xe5, 0x7e, 0x7f, 0x23, 0xdc,
	0x6d, 0x71, 0xdf, 0xc3, 0xe5, 0x1b, 0x39, 0xfe, 0xb7, 0x77, 0xe5, 0x72, 0x0d, 0x1c, 0x8d, 0xb7
};

char rsa_q_2048[] = {
	0x44, 0x58, 0xe8, 0x62, 0xc8, 0xd2, 0xb5, 0x45, 0x1f, 0xa5, 0xc3, 0xdb, 0x8e, 0x69, 0x42, 0xd2,
	0x21, 0x7e, 0x6b, 0x26, 0x69, 0x45, 0xf1, 0x33, 0xcf, 0xd7, 0xe6, 0x6e, 0x64, 0xc3, 0x29, 0xa5,
	0x68, 0x49, 0x3d, 0x13, 0x0b, 0x42, 0x36, 0xa6, 0xf4, 0xb1, 0xab, 0xa3, 0x8f, 0xe6, 0xcf, 0x46,
	0xe8, 0x85, 0xf3, 0xaa, 0xcb, 0x9,  0x84, 0x32, 0x34, 0xf7, 0x46, 0x0a, 0x65, 0xf9, 0xb5, 0x97,
	0xc2, 0x4a, 0x6f, 0x41, 0x40, 0xc9, 0x9e, 0x63, 0xe1, 0x0f, 0xd2, 0x12, 0x59, 0x35, 0xcc, 0x39,
	0x99, 0x4,  0xe8, 0x9a, 0xd2, 0x0,  0x7a, 0xce, 0x3c, 0x78, 0xfe, 0xea, 0x4b, 0x13, 0x53, 0xcd,
	0xc3, 0x60, 0x73, 0xa4, 0x3f, 0xbc, 0x8a, 0x8d, 0x61, 0x1c, 0xfa, 0xaf, 0xb7, 0xf8, 0x37, 0xa5,
	0xe2, 0x3a, 0xd2, 0x7a, 0xb6, 0x0,  0xf3, 0xd8, 0x3a, 0xa2, 0x46, 0xd2, 0x5c, 0x91, 0xc1, 0x5,
	0x6a, 0xf3, 0x2c, 0xd2, 0x2d, 0x55, 0xc1, 0x54, 0x40, 0x18, 0x71, 0x7,  0x96, 0xa9, 0x56, 0x6e,
	0x45, 0x58, 0x24, 0xce, 0x75, 0x80, 0x3,  0x68, 0x36, 0x96, 0x3,  0xb2, 0x9c, 0x25, 0xbc, 0x55,
	0x0d, 0xe8, 0xa1, 0x7d, 0xdd, 0x39, 0x87, 0x3c, 0xa1, 0x6a, 0xeb, 0x1b, 0x4f, 0x14, 0x72, 0x88,
	0x6c, 0x14, 0x6d, 0x24, 0xb7, 0xda, 0xf8, 0x97, 0xaa, 0xba, 0xb4, 0xdd, 0xc9, 0x5b, 0x28, 0x10,
	0x49, 0xfa, 0x93, 0xcc, 0x62, 0xc0, 0x70, 0xf8, 0xd6, 0xdc, 0xb2, 0x80, 0x35, 0x20, 0x84, 0xa4,
	0x99, 0xfc, 0x10, 0x7c, 0x9d, 0xc0, 0xc6, 0xd4, 0x8b, 0x0c, 0x57, 0xf1, 0x1,  0xf5, 0x1a, 0x4f,
	0x20, 0xfa, 0x8d, 0x66, 0x8b, 0x22, 0x3c, 0x96, 0xef, 0xd0, 0xde, 0xe5, 0x7e, 0x7f, 0x23, 0xdc,
	0x6d, 0x71, 0xdf, 0xc3, 0xe5, 0x1b, 0x39, 0xfe, 0xb7, 0x77, 0xe5, 0x72, 0x0d, 0x1c, 0x8d, 0xb7
};

enum dh_test_item {
	TEST_ITEM_INVALID,
	SW_GENERATE_KEY,
	SW_COMPUTE_KEY,
	HW_GENERATE_KEY,
	HW_COMPUTE_KEY,
};

struct hpre_dh_test_ctx_setup {
	void *x;
	void *p;
	void *g;
	void *except_pub_key;
	void *cp_pub_key;
	void *cp_share_key;
	u32 x_size;
	u32 p_size;
	u32 g_size;
	u32 cp_pub_key_size;
	u32 cp_share_key_size;
	u32 except_pub_key_size;
	u32 op_type;
	u32 generator;
	u32 key_bits;
	u32 key_from; //0 - Openssl  1 - Designed
	void *pool;
	void *q;
	void *ctx;
};

struct hpre_dh_sw_opdata {
	BIGNUM *except_pub_key;
	unsigned char *pub_key;
	u32 pub_key_size;
	unsigned char *share_key;
	u32 share_key_size;
};

struct hpre_dh_test_ctx {
	void *priv;
	void *opdata;
	unsigned char *cp_share_key;
	u32 cp_share_key_size;
	unsigned char *cp_pub_key;
	u32 cp_pub_key_size;
	u32 op;
	u32 key_size;
	void *pool;
};

struct hpre_rsa_test_key_in {
	void *e;
	void *p;
	void *q;
	u32 e_size;
	u32 p_size;
	u32 q_size;
	void *data[];
};

static __thread struct hpre_rsa_test_key_in *rsa_key_in = NULL;

/* OpenSSL RSA and BN APIs */
BIGNUM *BN_new(void);
int BN_bn2bin(const BIGNUM *a, unsigned char *to);
BIGNUM *BN_bin2bn(const unsigned char *s, int len, BIGNUM *ret);
void BN_free(BIGNUM *a);
BIGNUM *BN_dup(const BIGNUM *a);
RSA *RSA_new(void);
void RSA_free(RSA *rsa);
int BN_set_word(BIGNUM *a, BN_ULONG w);
int RSA_generate_key_ex(RSA *rsa, int bits, BIGNUM *e_value, BN_GENCB *cb);
void RSA_get0_key(const RSA *r,
				  const BIGNUM **n, const BIGNUM **e, const BIGNUM **d);
void RSA_get0_factors(const RSA *r, const BIGNUM **p, const BIGNUM **q);
void RSA_get0_crt_params(const RSA *r,
						 const BIGNUM **dmp1, const BIGNUM **dmq1,
						 const BIGNUM **iqmp);
int RSA_set0_crt_params(RSA *r, BIGNUM *dmp1, BIGNUM *dmq1,
						BIGNUM *iqmp);
int RSA_set0_key(RSA *r, BIGNUM *n, BIGNUM *e, BIGNUM *d);
int RSA_set0_factors(RSA *r, BIGNUM *p, BIGNUM *q);
int RSA_public_encrypt(int flen, const unsigned char *from,
					   unsigned char *to, RSA *rsa, int padding);
int RSA_private_decrypt(int flen, const unsigned char *from,
						unsigned char *to, RSA *rsa, int padding);
DH *DH_new(void);
void DH_free(DH *r);
int DH_generate_parameters_ex(DH *dh, int prime_len, int generator,
							  BN_GENCB *cb);
void DH_get0_pqg(const DH *dh, const BIGNUM **p, const BIGNUM **q,
				 const BIGNUM **g);
int DH_generate_key(DH *dh);
void DH_get0_key(const DH *dh, const BIGNUM **pub_key,
				 const BIGNUM **priv_key);
int DH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g);
int DH_set0_key(DH *dh, BIGNUM *pub_key, BIGNUM *priv_key);
int DH_compute_key(unsigned char *key, const BIGNUM *pub_key, DH *dh);
void *_hpre_sys_test_thread(void *data);

#ifdef DEBUG
static void print_data(void *ptr, int size, const char *name)
{
	__u32 i = 0;
	__u8* p = ptr;

	printf("\n%s:start_addr=%p, size %d\n", name, ptr, size);
	for (i = 1; i <= size; i++) {
		printf("%02x ", p[i - 1]);
		if (i % 16 == 0)
			printf("\n");
	}
}
#endif

static int init_opdata_param(void *pool,
			     struct wcrypto_dh_op_data *opdata,
			     int key_size, enum dh_check_index step)
{
	unsigned char *ag_bin = NULL;

	memset(opdata, 0, sizeof(*opdata));
	if (step == DH_ALICE_PRIVKEY) {
		ag_bin = wd_alloc_blk(pool);
		if (!ag_bin)
			return -ENOMEM;
		memset(ag_bin, 0, 2 * key_size);
		opdata->pv = ag_bin;
	}

	opdata->x_p = wd_alloc_blk(pool);
	if (!opdata->x_p) {
		if (ag_bin)
			wd_free_blk(pool, ag_bin);
		return -ENOMEM;
	}
	memset(opdata->x_p, 0, 2 * key_size);

	opdata->pri = wd_alloc_blk(pool);
	if (!opdata->pri) {
		if (ag_bin)
			wd_free_blk(pool, ag_bin);
		wd_free_blk(pool, opdata->x_p);
		return -ENOMEM;
	}
	memset(opdata->pri, 0, 2 * key_size);

	return 0;
}


void hpre_dh_del_test_ctx(struct hpre_dh_test_ctx *test_ctx)
{
	if (!test_ctx)
		return;

	if (SW_GENERATE_KEY == test_ctx->op) {
		DH_free(test_ctx->priv);
	} else if (SW_COMPUTE_KEY == test_ctx->op) {
		struct hpre_dh_sw_opdata *opdata = test_ctx->opdata;

		free(opdata->except_pub_key);
		free(opdata->share_key);
		free(opdata);
		DH_free(test_ctx->priv);
	} else if (HW_GENERATE_KEY == test_ctx->op) {
		struct wcrypto_dh_op_data *opdata = test_ctx->opdata;

		wd_free_blk(test_ctx->pool, opdata->x_p);
		wd_free_blk(test_ctx->pool, opdata->pri);
		free(opdata);
		free(test_ctx->cp_pub_key);
	} else if (HW_COMPUTE_KEY == test_ctx->op) {
		struct wcrypto_dh_op_data *opdata = test_ctx->opdata;

		wd_free_blk(test_ctx->pool, opdata->pv);
		wd_free_blk(test_ctx->pool, opdata->x_p);
		wd_free_blk(test_ctx->pool, opdata->pri);
		free(opdata);
		free(test_ctx->cp_share_key);
	} else {
		HPRE_TST_PRT("%s: no op %d\n", __func__, test_ctx->op);
	}

	free(test_ctx);
}

static struct hpre_dh_test_ctx *create_sw_gen_key_test_ctx(struct hpre_dh_test_ctx_setup setup)
{
	BIGNUM *p = NULL, *g = NULL, *x = NULL;
	struct hpre_dh_test_ctx *test_ctx;
	DH *dh = NULL;

	if (SW_GENERATE_KEY != setup.op_type) {
		HPRE_TST_PRT("%s: err op type %d\n", __func__, setup.op_type);
		return NULL;
	}

	dh = DH_new();
	if (!dh)
		return NULL;

	test_ctx = malloc(sizeof(struct hpre_dh_test_ctx));
	if (!test_ctx) {
		DH_free(dh);
		return NULL;
	}

	if (setup.key_from) {
		p = BN_bin2bn(setup.p, setup.p_size, NULL);
		g = BN_bin2bn(setup.g, setup.g_size, NULL);
		x = BN_bin2bn(setup.x, setup.x_size, NULL);
		DH_set0_pqg(dh, p, NULL, g);
		DH_set0_key(dh, NULL, x);
	} else {
		if (!DH_generate_parameters_ex(dh, setup.key_bits, setup.generator, NULL)) {
			HPRE_TST_PRT("DH_generate_parameters_ex fail!\n");
			DH_free(dh);
			free(test_ctx);
			return NULL;
		}
	}

	test_ctx->op = SW_GENERATE_KEY;
	test_ctx->priv = dh;
	test_ctx->key_size = setup.key_bits >> 3;

#ifdef DEBUG
	//DHparams_print_fp(stdout, dh);
#endif

	return test_ctx;
}

static struct hpre_dh_test_ctx *create_sw_compute_key_test_ctx(struct hpre_dh_test_ctx_setup setup)
{
	struct hpre_dh_sw_opdata *opdata;
	struct hpre_dh_test_ctx *test_ctx;
	DH *dh = NULL;

	if (!setup.except_pub_key ||
		!setup.except_pub_key_size ||
		setup.op_type !=SW_COMPUTE_KEY) {
		HPRE_TST_PRT("%s: parm err!\n", __func__);
		return NULL;
	}

	dh = DH_new();
	if (!dh)
		return NULL;

	opdata = malloc(sizeof(struct hpre_dh_sw_opdata));
	if (!opdata) {
		DH_free(dh);
		return NULL;
	}
	memset(opdata, 0, sizeof(struct hpre_dh_sw_opdata));

	test_ctx = malloc(sizeof(struct hpre_dh_test_ctx));
	if (!test_ctx) {
		DH_free(dh);
		free(opdata);
		return NULL;
	}
	memset(test_ctx, 0, sizeof(struct hpre_dh_test_ctx));

	opdata->share_key = malloc(setup.key_bits >> 3);
	if (!opdata->share_key) {
		DH_free(dh);
		free(opdata);
		free(test_ctx);
		return NULL;
	}

	if (setup.key_from) {
		BIGNUM *p = NULL, *g = NULL, *x = NULL;
		p = BN_bin2bn(setup.p, setup.p_size, NULL);
		g = BN_bin2bn(setup.g, setup.g_size, NULL);
		x = BN_bin2bn(setup.x, setup.x_size, NULL);
		DH_set0_pqg(dh, p, NULL, g);
		DH_set0_key(dh, NULL, x);

		opdata->except_pub_key = BN_bin2bn(setup.except_pub_key,
					setup.except_pub_key_size, NULL);

	} else {
		opdata->except_pub_key = BN_bin2bn(setup.except_pub_key,
			setup.except_pub_key_size, NULL);

		if (!DH_generate_parameters_ex(dh, setup.key_bits, setup.generator, NULL)) {
			HPRE_TST_PRT("DH_generate_parameters_ex fail!\n");
			goto exit_free;
		}

		if (!DH_generate_key(dh)) {
			HPRE_TST_PRT("Alice DH_generate_key fail!\n");
			goto exit_free;
		}
	}
#ifdef DEBUG
	//DHparams_print_fp(stdout, dh);
#endif
	test_ctx->op = SW_COMPUTE_KEY;
	test_ctx->priv = dh;
	test_ctx->opdata = opdata;
	test_ctx->key_size = setup.key_bits >> 3;

	return test_ctx;

exit_free:
	hpre_dh_del_test_ctx(test_ctx);

	return NULL;
}

static struct hpre_dh_test_ctx *create_hw_gen_key_test_ctx(struct hpre_dh_test_ctx_setup setup)
{
	const BIGNUM *p = NULL, *g = NULL, *x = NULL;
	const BIGNUM *pub_key = NULL;
	struct wcrypto_dh_op_data *opdata;
	struct hpre_dh_test_ctx *test_ctx;
	struct wd_dtb ctx_g;
	int ret;
	u32 key_size = setup.key_bits >> 3;
	DH *dh = NULL;

	if (!setup.q || !setup.pool || setup.op_type !=HW_GENERATE_KEY) {
		HPRE_TST_PRT("%s: parm err!\n", __func__);
		return NULL;
	}

	opdata = malloc(sizeof(struct wcrypto_dh_op_data));
	if (!opdata)
		return NULL;
	memset(opdata, 0, sizeof(struct hpre_dh_sw_opdata));

	dh = DH_new();
	if (!dh) {
		free(opdata);
		return NULL;
	}

	test_ctx = malloc(sizeof(struct hpre_dh_test_ctx));
	if (!test_ctx) {
		free(opdata);
		DH_free(dh);
		return NULL;
	}
	memset(test_ctx, 0, sizeof(struct hpre_dh_test_ctx));

	ctx_g.data = malloc(key_size);
	if (!ctx_g.data) {
		free(test_ctx);
		free(opdata);
		DH_free(dh);
		return NULL;
	}
	memset(ctx_g.data, 0, key_size);

	test_ctx->cp_pub_key = malloc(key_size);
	if (!test_ctx->cp_pub_key) {
		free(test_ctx);
		free(opdata);
		DH_free(dh);
		free(ctx_g.data);
		return NULL;
	}

	ret = init_opdata_param(setup.pool, opdata, key_size, DH_ALICE_PUBKEY);
	if (ret < 0) {
		HPRE_TST_PRT("init_opdata_param failed\n");
		free(test_ctx);
		free(opdata);
		DH_free(dh);
		free(ctx_g.data);
		return NULL;
	}

	if (setup.key_from) {
		if (!setup.x || !setup.x_size || !setup.p || !setup.cp_pub_key ||
			!setup.p_size || !setup.g || !setup.g_size || !setup.cp_pub_key_size) {
			HPRE_TST_PRT("%s: x/p/g parm err\n", __func__);
			goto exit_free;
		}

		memcpy(opdata->x_p, setup.x, setup.x_size);
		memcpy(opdata->x_p + key_size, setup.p, setup.p_size);
		memcpy(ctx_g.data, setup.g, setup.g_size);
		memcpy(test_ctx->cp_pub_key, setup.cp_pub_key, setup.cp_pub_key_size);
		opdata->pbytes = setup.p_size;
		opdata->xbytes = setup.x_size;
		ctx_g.dsize = setup.g_size;
		ctx_g.bsize = key_size;
		test_ctx->cp_pub_key_size = setup.cp_pub_key_size;
	} else {
		ret = DH_generate_parameters_ex(dh, setup.key_bits, setup.generator, NULL);
		if (!ret) {
			HPRE_TST_PRT("DH_generate_parameters_ex failed\n");
			goto exit_free;
		}

		if (!DH_generate_key(dh)) {
			HPRE_TST_PRT("DH_generate_key failed\n");
			goto exit_free;
		}

		DH_get0_pqg(dh, &p, NULL, &g);
		DH_get0_key(dh, &pub_key, &x);

		opdata->pbytes = BN_bn2bin(p, opdata->x_p + key_size);
		opdata->xbytes = BN_bn2bin(x, opdata->x_p);
		ctx_g.dsize = BN_bn2bin(g, (unsigned char*)ctx_g.data);
		ctx_g.bsize = key_size;
		test_ctx->cp_pub_key_size = BN_bn2bin(pub_key, test_ctx->cp_pub_key);
	}

#ifdef DEBUG
		print_data(ctx_g.data, ctx_g.dsize, "g");
		print_data(opdata->x_p, opdata->xbytes, "x");
		print_data(opdata->x_p + key_size, opdata->pbytes, "p");
		print_data(test_ctx->cp_pub_key, test_ctx->cp_pub_key_size, "cp_pub_key");
#endif

	opdata->op_type = WCRYPTO_DH_PHASE1;
	test_ctx->opdata = opdata;
	test_ctx->pool = setup.pool;
	test_ctx->op = setup.op_type;
	test_ctx->priv = setup.ctx; //init ctx
	test_ctx->key_size = key_size;

	ret = wcrypto_set_dh_g(test_ctx->priv, &ctx_g);
	if (ret) {
		HPRE_TST_PRT("wcrypto_set_dh_g failed\n");
		goto exit_free;
	}


	DH_free(dh);
	free(ctx_g.data);

	return test_ctx;
exit_free:
	DH_free(dh);
	free(ctx_g.data);
	hpre_dh_del_test_ctx(test_ctx);

	return NULL;
}

static struct hpre_dh_test_ctx *create_hw_compute_key_test_ctx(struct hpre_dh_test_ctx_setup setup)
{
	const BIGNUM *p = NULL, *g = NULL, *x = NULL;
	struct wcrypto_dh_op_data *opdata;
	struct hpre_dh_test_ctx *test_ctx;
	int ret;
	u32 key_size = setup.key_bits >> 3;
	DH *dh = NULL;
	DH *b = NULL;

	if (!setup.q || !setup.pool || setup.op_type !=HW_COMPUTE_KEY) {
		HPRE_TST_PRT("%s: parm err!\n", __func__);
		return NULL;
	}

	opdata = malloc(sizeof(struct wcrypto_dh_op_data));
	if (!opdata)
		return NULL;
	memset(opdata, 0, sizeof(struct wcrypto_dh_op_data));

	dh = DH_new();
	if (!dh) {
		free(opdata);
		return NULL;
	}

	test_ctx = malloc(sizeof(struct hpre_dh_test_ctx));
	if (!test_ctx) {
		free(opdata);
		DH_free(dh);
		return NULL;
	}
	memset(test_ctx, 0, sizeof(struct hpre_dh_test_ctx));

	test_ctx->cp_share_key = malloc(key_size);
	if (!test_ctx->cp_share_key) {
		free(test_ctx);
		free(opdata);
		DH_free(dh);
		return NULL;
	}

	ret = init_opdata_param(setup.pool, opdata, key_size, DH_ALICE_PRIVKEY);
	if (ret < 0) {
		HPRE_TST_PRT("init_opdata_param failed\n");
		free(test_ctx);
		free(opdata);
		DH_free(dh);
		return NULL;
	}

	if (setup.key_from) {
		memcpy(opdata->x_p, setup.x, setup.x_size);
		memcpy(opdata->x_p + key_size, setup.p, setup.p_size);
		memcpy(opdata->pv, setup.except_pub_key, setup.except_pub_key_size);
		memcpy(test_ctx->cp_share_key, setup.cp_share_key, setup.cp_share_key_size);
		opdata->pbytes = setup.p_size;
		opdata->xbytes = setup.x_size;
		opdata->pvbytes = setup.except_pub_key_size;
		test_ctx->cp_share_key_size = setup.cp_share_key_size;
	} else {
		const BIGNUM *bp = NULL, *bg = NULL,
				*bpub_key = NULL, *bpriv_key = NULL;
		b = DH_new();

		ret = DH_generate_parameters_ex(dh, setup.key_bits, setup.generator, NULL);
		if (!ret) {
			HPRE_TST_PRT("DH_generate_parameters_ex fail!\n");
			goto exit_free;
		}

		if (!DH_generate_key(dh)) {
			HPRE_TST_PRT("Alice DH_generate_key fail!\n");
			goto exit_free;
		}

		DH_get0_pqg(dh, &p, NULL, &g);
		DH_get0_key(dh, NULL, &x);
		bp = BN_dup(p);
		bg = BN_dup(g);
		DH_set0_pqg(b, (BIGNUM *)bp, NULL, (BIGNUM *)bg);
		if (!DH_generate_key(b)) {
			HPRE_TST_PRT("a DH_generate_key fail!\n");
			ret = -1;
			goto exit_free;
		}
		DH_get0_key(b, &bpub_key, &bpriv_key);

		test_ctx->cp_share_key_size = DH_compute_key(test_ctx->cp_share_key, bpub_key, dh);
		if (!test_ctx->cp_share_key_size || test_ctx->cp_share_key_size == -1) {
			HPRE_TST_PRT("DH_compute_key fail!\n");
			goto exit_free;
		}

		opdata->pbytes = BN_bn2bin(p, opdata->x_p + key_size);
		opdata->xbytes = BN_bn2bin(x, opdata->x_p);
		opdata->pvbytes = setup.except_pub_key_size;
		opdata->pvbytes = BN_bn2bin(bpub_key, opdata->pv);
	}

	opdata->op_type = WCRYPTO_DH_PHASE2;
	test_ctx->priv = setup.ctx; //init ctx
	test_ctx->opdata = opdata;
	test_ctx->pool = setup.pool;
	test_ctx->op = setup.op_type;
	test_ctx->key_size = key_size;

#ifdef DEBUG
	print_data(opdata->pv, opdata->pvbytes, "pv");
	print_data(opdata->x_p, opdata->xbytes, "x");
	print_data(opdata->x_p + key_size, opdata->pbytes, "p");
	print_data(test_ctx->cp_share_key, test_ctx->cp_share_key_size, "cp_share_key");
#endif

	DH_free(dh);
	if (b)
		DH_free(b);

	return test_ctx;
exit_free:
	DH_free(dh);
	if (b)
		DH_free(b);
	hpre_dh_del_test_ctx(test_ctx);

	return NULL;
}


struct hpre_dh_test_ctx *hpre_dh_create_test_ctx(struct hpre_dh_test_ctx_setup setup)
{
	struct hpre_dh_test_ctx *test_ctx = NULL;

	switch (setup.op_type) {
		case SW_GENERATE_KEY:
		{
			test_ctx = create_sw_gen_key_test_ctx(setup);
		}
		break;
		case HW_GENERATE_KEY:
		{
			test_ctx = create_hw_gen_key_test_ctx(setup);
		}
		break;
		case SW_COMPUTE_KEY:
		{
			test_ctx = create_sw_compute_key_test_ctx(setup);
		}
		break;
		case HW_COMPUTE_KEY:
		{
			test_ctx = create_hw_compute_key_test_ctx(setup);
		}
		break;
		default:
		break;
	}

	return test_ctx;
}

int dh_generate_key(void *test_ctx, void *tag)
{
	struct hpre_dh_test_ctx *t_c = test_ctx;
	int ret = 0;

	if (t_c->op == SW_GENERATE_KEY) {
		DH *dh = t_c->priv;

		if (!DH_generate_key(dh)) {
			HPRE_TST_PRT("DH_generate_key fail!\n");
			return -1;
		}

#ifdef DEBUG
		//DHparams_print_fp(stdout, dh);
#endif

	} else {
		struct wcrypto_dh_op_data *opdata = t_c->opdata;
		void* ctx = t_c->priv;
try_again:
		ret = wcrypto_do_dh(ctx, opdata, tag);
		if (ret == -WD_EBUSY) {
			usleep(100);
			goto try_again;
		} else if (ret) {
			HPRE_TST_PRT("wcrypto_do_dh fail!\n");
			return -1;
		}
	}

	return 0;
}

int dh_compute_key(void *test_ctx, void *tag)
{
	struct hpre_dh_test_ctx *t_c = test_ctx;
	int ret = 0;

	if (t_c->op == SW_COMPUTE_KEY) {
		struct hpre_dh_sw_opdata *opdata = t_c->opdata;
		DH *dh = t_c->priv;

		ret = DH_compute_key(opdata->share_key, opdata->except_pub_key, dh);
		if (ret <= 0) {
			HPRE_TST_PRT("DH_compute_key fail!\n");
			return -1;
		}
		opdata->share_key_size = ret;

#ifdef DEBUG
	//DHparams_print_fp(stdout, dh);
	//print_data(opdata->share_key, ret, "openssl share key");

#endif
	} else {
		struct wcrypto_dh_op_data *opdata = t_c->opdata;
		void* ctx = t_c->priv;
try_again:

		ret = wcrypto_do_dh(ctx, opdata, tag);
		if (ret == -WD_EBUSY) {
			usleep(100);
			goto try_again;
		} else if (ret) {
			HPRE_TST_PRT("wcrypto_do_dh fail!\n");
			return -1;
		}
#ifdef DEBUG
		//print_data(opdata->pri, opdata->pri_bytes,"hpre share key");
#endif
	}

	return 0;
}

static bool is_exit(struct test_hpre_pthread_dt *pdata)
{
	struct timeval cur_tval;
	float time_used;

	if (!performance_test)
		return false;

	gettimeofday(&cur_tval, NULL);
	time_used = (float)((cur_tval.tv_sec -pdata->start_tval.tv_sec) * 1000000 +
			cur_tval.tv_usec - pdata->start_tval.tv_usec);

	if (t_seconds)
		return time_used >= t_seconds * 1000000;
	else if (t_times)
		return pdata->send_task_num >= t_times;

	return false;
}

static int dh_result_check(struct hpre_dh_test_ctx *test_ctx)
{
	struct wcrypto_dh_op_data *opdata = test_ctx->opdata;
	unsigned char *cp_key;
	u32 cp_size;

	if (test_ctx->op == HW_GENERATE_KEY) {
		cp_key = test_ctx->cp_pub_key;
		cp_size = test_ctx->cp_pub_key_size;

	} else {
		cp_key = test_ctx->cp_share_key;
		cp_size = test_ctx->cp_share_key_size;
	}

	if (opdata->pri_bytes != cp_size || memcmp(cp_key, opdata->pri, cp_size)) {
		HPRE_TST_PRT("dh op %d mismatch!\n", test_ctx->op);

#ifdef DEBUG
	print_data(opdata->pri, opdata->pri_bytes, "hpre out");
	print_data(cp_key, cp_size, "openssl out");
#endif

		return -1;
	}

	return 0;

}

static bool is_allow_print(int cnt, enum alg_op_type opType, int thread_num)
{
	int intval_index = 0;
	unsigned int log_intval_adjust = 0;
	int log_intval[LOG_INTVL_NUM] = {0x1, 0xff, 0x3ff, 0x7ff, 0xfff, 0x1fff};

	if (!with_log)
		return false;

	if (only_soft)
		return true;

	switch (opType) {
		case RSA_ASYNC_GEN:
		case RSA_ASYNC_EN:
		case RSA_ASYNC_DE:
		case DH_ASYNC_COMPUTE:
		case DH_ASYNC_GEN:
		case RSA_KEY_GEN:
		{
			intval_index = 0x04;
		}
		break;
		case DH_COMPUTE:
		case DH_GEN:
		{
			intval_index = 0x00;
		}
		break;
		default:
		{
			intval_index = 0x01;
		}
		break;
	}

	if (!thread_num)
		return false;
	log_intval_adjust = log_intval[intval_index] * ((thread_num - 1) / 16 + 1);

	if (!(cnt % log_intval_adjust))
		return true;
	else
		return false;
}

static void _dh_perf_cb(const void *message, void *tag)
{
	//const struct wcrypto_dh_msg *msg = message;
	struct dh_user_tag_info* pTag = (struct dh_user_tag_info*)tag;
	struct test_hpre_pthread_dt *thread_data = pTag->thread_data;

	thread_data->recv_task_num++;

	//hpre_dh_del_test_ctx(pTag->test_ctx);
	free(pTag);
}

static void _dh_cb(const void *message, void *tag)
{
	const struct wcrypto_dh_msg *msg = message;
	struct dh_user_tag_info* pSwData = (struct dh_user_tag_info*)tag;
	struct timeval start_tval, end_tval;
	int pid, threadId;
	float time, speed;
	int ret;
	static int failTimes = 0;
	struct hpre_dh_test_ctx *test_ctx = pSwData->test_ctx;
	struct wcrypto_dh_op_data *opdata = test_ctx->opdata;
	struct test_hpre_pthread_dt *thread_data = pSwData->thread_data;

	start_tval = thread_data->start_tval;
	pid = pSwData->pid;
	threadId = pSwData->thread_id;

	if (opdata->status != WD_SUCCESS) {
		HPRE_TST_PRT("Proc-%d, %d-TD dh %dtimes fail!, status 0x%02x\n",
				 pid, threadId, thread_data->send_task_num, opdata->status);
		goto err;
	}

	if (openssl_check) {
		opdata->pri_bytes = msg->out_bytes;
		ret = dh_result_check(test_ctx);
		if (ret) {
			failTimes++;
			HPRE_TST_PRT("TD-%d:dh %d result mismatching!\n",
				threadId, test_ctx->op);
		}
	}

	gettimeofday(&end_tval, NULL);
	if (is_allow_print(thread_data->send_task_num, DH_ASYNC_GEN, 1)) {
		time = (end_tval.tv_sec - start_tval.tv_sec) * 1000000 +
					(end_tval.tv_usec - start_tval.tv_usec);
		speed = 1 / (time / thread_data->send_task_num) * 1000 * 1000;
		HPRE_TST_PRT("Proc-%d, %d-TD dh %dtimes,%f us, %0.3fps, fail %dtimes(all TD)\n",
				 pid, threadId, thread_data->send_task_num, time, speed, failTimes);
	}

err:
	if (pSwData)
		free(pSwData);
}


int dh_init_test_ctx_setup(struct hpre_dh_test_ctx_setup *setup)
{
	if (!setup)
		return -1;

	if (!strcmp(g_mode, "-g2"))
		setup->generator = DH_GENERATOR_2;
	else
		setup->generator = DH_GENERATOR_5;

	if (performance_test)
		setup->key_from = 1; //0 - Openssl  1 - Designed
	else
		setup->key_from = 0; //0 - Openssl  1 - Designed

	setup->key_bits = key_bits;

	if (key_bits == 768) {
		setup->x = dh_xa_768;
		setup->p = dh_p_768;
		setup->except_pub_key = dh_except_b_pubkey_768;
		setup->cp_pub_key = dh_except_a_pubkey_768;
		setup->cp_share_key = dh_share_key_768;
		setup->x_size = sizeof(dh_xa_768);
		setup->p_size = sizeof(dh_p_768);
		setup->except_pub_key_size = sizeof(dh_except_b_pubkey_768);
		setup->cp_pub_key_size = sizeof(dh_except_a_pubkey_768);
		setup->cp_share_key_size = sizeof(dh_share_key_768);
	} else if (key_bits == 1024) {
		setup->x = dh_xa_1024;
		setup->p = dh_p_1024;
		setup->except_pub_key = dh_except_b_pubkey_1024;
		setup->cp_pub_key = dh_except_a_pubkey_1024;
		setup->cp_share_key = dh_share_key_1024;
		setup->x_size = sizeof(dh_xa_1024);
		setup->p_size = sizeof(dh_p_1024);
		setup->except_pub_key_size = sizeof(dh_except_b_pubkey_1024);
		setup->cp_pub_key_size = sizeof(dh_except_a_pubkey_1024);
		setup->cp_share_key_size = sizeof(dh_share_key_1024);
	} else if (key_bits == 1536) {
		setup->x = dh_xa_1536;
		setup->p = dh_p_1536;
		setup->except_pub_key = dh_except_b_pubkey_1536;
		setup->cp_pub_key = dh_except_a_pubkey_1536;
		setup->cp_share_key = dh_share_key_1536;
		setup->x_size = sizeof(dh_xa_1536);
		setup->p_size = sizeof(dh_p_1536);
		setup->except_pub_key_size = sizeof(dh_except_b_pubkey_1536);
		setup->cp_pub_key_size = sizeof(dh_except_a_pubkey_1536);
		setup->cp_share_key_size = sizeof(dh_share_key_1536);
	} else if (key_bits == 2048) {
		setup->x = dh_xa_2048;
		setup->p = dh_p_2048;
		setup->except_pub_key = dh_except_b_pubkey_2048;
		setup->cp_pub_key = dh_except_a_pubkey_2048;
		setup->cp_share_key = dh_share_key_2048;
		setup->x_size = sizeof(dh_xa_2048);
		setup->p_size = sizeof(dh_p_2048);
		setup->except_pub_key_size = sizeof(dh_except_b_pubkey_2048);
		setup->cp_pub_key_size = sizeof(dh_except_a_pubkey_2048);
		setup->cp_share_key_size = sizeof(dh_share_key_2048);
	} else if (key_bits == 3072) {
		setup->x = dh_xa_3072;
		setup->p = dh_p_3072;
		setup->except_pub_key = dh_except_b_pubkey_3072;
		setup->cp_pub_key = dh_except_a_pubkey_3072;
		setup->cp_share_key = dh_share_key_3072;
		setup->x_size = sizeof(dh_xa_3072);
		setup->p_size = sizeof(dh_p_3072);
		setup->except_pub_key_size = sizeof(dh_except_b_pubkey_3072);
		setup->cp_pub_key_size = sizeof(dh_except_a_pubkey_3072);
		setup->cp_share_key_size = sizeof(dh_share_key_3072);
	} else if (key_bits == 4096) {
		setup->x = dh_xa_4096;
		setup->p = dh_p_4096;
		setup->except_pub_key = dh_except_b_pubkey_4096;
		setup->cp_pub_key = dh_except_a_pubkey_4096;
		setup->cp_share_key = dh_share_key_4096;
		setup->x_size = sizeof(dh_xa_4096);
		setup->p_size = sizeof(dh_p_4096);
		setup->except_pub_key_size = sizeof(dh_except_b_pubkey_4096);
		setup->cp_pub_key_size = sizeof(dh_except_a_pubkey_4096);
		setup->cp_share_key_size = sizeof(dh_share_key_4096);
	} else {
		HPRE_TST_PRT("not find this keybits %d\n", key_bits);
		return -1;
	}

	if (!strcmp(g_mode, "-g2")) {
		setup->g = dh_g_2;
	} else {
		setup->g = dh_g_5;
	}
	setup->g_size = 1;

	return 0;
}

static void *_hpre_dh_sys_test_thread(void *data)
{
	struct test_hpre_pthread_dt *pdata = data;
	struct dh_user_tag_info *pTag = NULL;
	struct hpre_dh_test_ctx *test_ctx;
	struct hpre_dh_test_ctx_setup setup;
	struct timeval cur_tval;
	enum alg_op_type opType;
	float time_used, speed;
	int thread_num;
	cpu_set_t mask;
	int pid = getpid();
	int thread_id = (int)syscall(__NR_gettid);
	int ret, cpuid, opstr_idx = 0;
	struct wd_queue *q = NULL;
	void *pool = NULL;
	void *ctx = NULL;
	struct wcrypto_dh_ctx_setup dh_setup;

	CPU_ZERO(&mask);
	cpuid = pdata->cpu_id;
	q = (struct wd_queue *)pdata->q;
	pool = pdata->pool;
	opType = pdata->op_type;
	thread_num = pdata->thread_num;

	if (performance_test && (!t_times && !t_seconds)) {
		HPRE_TST_PRT("t_times or  t_seconds err\n");
		return NULL;
	}

	if (!q || !pool) {
		HPRE_TST_PRT("q or pool null!\n");
		return NULL;
	}

	CPU_SET(cpuid, &mask);
	if (cpuid) {
		ret = pthread_setaffinity_np(pthread_self(), sizeof(mask), &mask);
		if (ret < 0) {
			HPRE_TST_PRT("Proc-%d, thrd-%d:set affinity fail!\n",
						 pid, thread_id);
			return NULL;
		}
		HPRE_TST_PRT("Proc-%d, thrd-%d bind to cpu-%d!\n",
					 pid, thread_id, cpuid);
	}

	if (!only_soft) {
		memset(&dh_setup, 0, sizeof(dh_setup));
		dh_setup.key_bits = key_bits;
		if (performance_test)
			dh_setup.cb = _dh_perf_cb;
		else
			dh_setup.cb = _dh_cb;
		dh_setup.br.alloc = (void *)wd_alloc_blk;
		dh_setup.br.free = (void *)wd_free_blk;
		dh_setup.br.iova_map = (void *)wd_blk_iova_map;
		dh_setup.br.iova_unmap = (void *)wd_blk_iova_unmap;
		dh_setup.br.usr = pool;
		if (!strcmp(g_mode, "-g2"))
			dh_setup.is_g2 = true;
		else
			dh_setup.is_g2 = false;

		ctx = wcrypto_create_dh_ctx(q, &dh_setup);
		if (!ctx) {
			HPRE_TST_PRT("wcrypto_create_dh_ctx failed\n");
			return NULL;
		}
	}

	if (dh_init_test_ctx_setup(&setup)) {
		wcrypto_del_dh_ctx(ctx);
		return NULL;
	}

	setup.pool = pool;
	setup.q = q;
	setup.ctx = ctx;

	if (opType == DH_ASYNC_GEN || opType == DH_GEN)
		setup.op_type = (only_soft) ? SW_GENERATE_KEY: HW_GENERATE_KEY;
	else
		setup.op_type = (only_soft) ? SW_COMPUTE_KEY: HW_COMPUTE_KEY;

new_test_again:
	test_ctx = hpre_dh_create_test_ctx(setup);
	if (!test_ctx) {
		HPRE_TST_PRT("hpre_dh_create_test_ctx failed\n");
		return NULL;
	}

	HPRE_TST_PRT("thrd-%d create test ctx finish\n", thread_id);

	do {
		if (opType == DH_ASYNC_GEN ||
			opType == DH_ASYNC_COMPUTE) {

			pTag = malloc(sizeof(struct dh_user_tag_info));
			if (!pTag) {
				HPRE_TST_PRT("malloc pTag fail!\n");
				goto fail_release;
			}

			pTag->test_ctx = test_ctx;
			pTag->thread_data = pdata;
			pTag->pid = pid;
			pTag->thread_id = thread_id;
		}

		if (opType == DH_ASYNC_GEN || opType == DH_GEN) {
			if (dh_generate_key(test_ctx, pTag)) {
				goto fail_release;
			}
			opstr_idx = 0;
		} else {
			if (dh_compute_key(test_ctx, pTag)) {
				goto fail_release;
			}
			opstr_idx = 1;
		}

		pdata->send_task_num++;
		if (opType == DH_GEN ||opType == DH_COMPUTE) {
			if (!performance_test && !only_soft) {
				if (dh_result_check(test_ctx))
					goto fail_release;

				if (is_allow_print(pdata->send_task_num, opType, thread_num)) {
					HPRE_TST_PRT("Proc-%d, %d-TD dh %s succ!\n",
						getpid(), (int)syscall(__NR_gettid), dh_op_str[opstr_idx]);
				}

				hpre_dh_del_test_ctx(test_ctx);
				goto new_test_again;
			}
		}

	}while(!is_exit(pdata));

	if (opType == DH_GEN || opType == DH_COMPUTE)
		pdata->recv_task_num = pdata->send_task_num;

	if (performance_test) {
		gettimeofday(&cur_tval, NULL);
		time_used = (float)((cur_tval.tv_sec -pdata->start_tval.tv_sec) * 1000000 +
				cur_tval.tv_usec - pdata->start_tval.tv_usec);

		if (t_seconds){
			speed = pdata->send_task_num / time_used * 1000000;
			HPRE_TST_PRT("Proc-%d, %d-TD: dh do %s send %u task, recv %u task, run %0.1f s at %0.3f ops\n",
				 pid, thread_id, dh_op_str[opstr_idx],
				pdata->send_task_num, pdata->recv_task_num,
				time_used / 1000000, speed);
		} else if (t_times) {
			speed = 1 / (time_used / t_times) * 1000;
			HPRE_TST_PRT("\r\nPID(%d)-thread-%d:%s g2 mode %dbits kgen %s time %0.0f us, pkt len ="
				" %d bytes, %0.3f Kops\n", getpid(), (int)syscall(__NR_gettid), "dh",
				key_bits, dh_op_str[opstr_idx],time_used, key_bits / 8, speed);
		}
	}

	/* wait for recv finish */
	while (pdata->send_task_num != pdata->recv_task_num)
		usleep(1000);

fail_release:

	if (test_ctx->op == HW_COMPUTE_KEY || test_ctx->op == HW_GENERATE_KEY)
		wcrypto_del_dh_ctx(test_ctx->priv);

	if (opType == DH_GEN || opType == DH_COMPUTE)
		hpre_dh_del_test_ctx(test_ctx);

	return NULL;
}

static inline int _get_cpu_id(int thr, __u64 core_mask)
{
	__u64 i;
	int cnt = 0;


	for (i = 1; i < 64; i++) {
		if (core_mask & (0x1ull << i)) {
			if (thr == cnt)
				return i;
			cnt++;
		}
	}

	return 0;
}

static inline int _get_one_bits(__u64 val)
{
	int count = 0;

	while (val) {
		if (val % 2 == 1)
			count++;
		val = val / 2;
	}

	return count;
}

int  hpre_test_get_file_size(char *in_file)
{
	int fd = -1, ret;
	struct stat file_info;

	if (!in_file) {
		HPRE_TST_PRT("para err while try to %s!\n", __func__);
		return -EINVAL;
	}
	fd = open(in_file, O_RDONLY, S_IRUSR) ;
	if (fd < 0) {
		HPRE_TST_PRT("Get %s file fail!\n", in_file);
		return fd;
	}
	ret = fstat(fd, &file_info);
	if (ret < 0) {
		close(fd);
		HPRE_TST_PRT("fstat file %s fail!\n", in_file);
		return -ret;
	}
	close(fd);
	return (int)file_info.st_size;
}

int  hpre_test_read_from_file(__u8 *out, char *in_file, int size)
{
	int fd = -1, bytes_rd;

	if (!out || !size || !in_file) {
		HPRE_TST_PRT("para err while try to write file!\n");
		return -EINVAL;
	}

	fd = open(in_file, O_RDONLY, S_IRUSR) ;
	if (fd < 0) {
		HPRE_TST_PRT("Get %s file fail!\n", in_file);
		return fd;
	}

	bytes_rd = read(fd, out, size);
	if (bytes_rd < 0) {
		close(fd);
		HPRE_TST_PRT("write data to %s file fail!\n", in_file);
		return -ENOMEM;
	}
	close(fd);

	/* to be fixed */
	return bytes_rd;
}

int hpre_test_write_to_file(__u8 *out, int size, char *out_file,
							int handle, int try_close)
{
	int fd = -1, bytes_write;

	if (!out || !size || !out_file) {
		HPRE_TST_PRT("para err while try to write file!\n");
		return -EINVAL;
	}

	if (handle < 0) {
		fd = open(out_file, O_WRONLY | O_CREAT,
				  S_IRUSR | S_IWUSR);
		if (fd < 0) {
			HPRE_TST_PRT("create %s file fail!\n", out_file);
			return fd;
		}
	} else
		fd = handle;

	bytes_write = write(fd, out, size);
	if (bytes_write < 0 || bytes_write < size) {
		if (try_close)
			close(fd);
		HPRE_TST_PRT("write data to %s file fail!\n", out_file);
		return -ENOMEM;
	}
	if (try_close)
		close(fd);

	/* to be fixed */
	return fd;
}

static int test_rsa_key_gen(void *ctx, char *pubkey_file,
			char *privkey_file,
			char *crt_privkey_file, int is_file)
{
	int ret, bits;
	RSA *test_rsa;
	BIGNUM *p, *q, *e_value, *n, *e, *d, *dmp1, *dmq1, *iqmp;
	//struct wd_dtb *wd_e, *wd_d, *wd_n, *wd_dq, *wd_dp, *wd_qinv, *wd_q, *wd_p;
	struct wd_dtb wd_e, wd_d, wd_n, wd_dq, wd_dp, wd_qinv, wd_q, wd_p;
	struct wcrypto_rsa_pubkey *pubkey;
	struct wcrypto_rsa_prikey *prikey;
	u32 key_size = key_bits >> 3;

	memset(&wd_e, 0, sizeof(wd_e));
	memset(&wd_d, 0, sizeof(wd_d));
	memset(&wd_n, 0, sizeof(wd_n));
	memset(&wd_dq, 0, sizeof(wd_dq));
	memset(&wd_dp, 0, sizeof(wd_dp));
	memset(&wd_qinv, 0, sizeof(wd_qinv));
	memset(&wd_q, 0, sizeof(wd_q));
	memset(&wd_p, 0, sizeof(wd_p));

	bits = wcrypto_rsa_key_bits(ctx);
	test_rsa = RSA_new();
	if (!test_rsa || !bits) {
		HPRE_TST_PRT("RSA new fail!\n");
		return -ENOMEM;
	}
	e_value = BN_new();
	if (!e_value) {
		RSA_free(test_rsa);
		HPRE_TST_PRT("BN new e fail!\n");
		ret = -ENOMEM;
		return ret;
	}
	ret = BN_set_word(e_value, 65537);
	if (ret != 1) {
		HPRE_TST_PRT("BN_set_word fail!\n");
		ret = -1;
		goto gen_fail;
	}
	ret = RSA_generate_key_ex(test_rsa, key_bits, e_value, NULL);
	if (ret != 1) {
		HPRE_TST_PRT("RSA_generate_key_ex fail!\n");
		ret = -1;
		goto gen_fail;
	}
	RSA_get0_key((const RSA *)test_rsa, (const BIGNUM **)&n,
			 (const BIGNUM **)&e, (const BIGNUM **)&d);
	RSA_get0_factors((const RSA *)test_rsa, (const BIGNUM **)&p,
			 (const BIGNUM **)&q);
	RSA_get0_crt_params((const RSA *)test_rsa, (const BIGNUM **)&dmp1,
			(const BIGNUM **)&dmq1, (const BIGNUM **)&iqmp);
	//wcrypto_get_rsa_pubkey(ctx, &pubkey);
	//wcrypto_get_rsa_pubkey_params(pubkey, &wd_e, &wd_n);
	wd_e.bsize = key_size;
	wd_e.data = malloc(GEN_PARAMS_SZ(key_size));
	wd_n.bsize = wd_e.bsize;
	wd_n.data = wd_e.data + wd_e.bsize;

	wd_e.dsize = BN_bn2bin(e, (unsigned char *)wd_e.data);
	if (wd_e.dsize > wd_e.bsize) {
		HPRE_TST_PRT("e bn to bin overflow!\n");
		goto gen_fail;
	}
	wd_n.dsize = BN_bn2bin(n, (unsigned char *)wd_n.data);
	if (wd_n.dsize > wd_n.bsize) {
		HPRE_TST_PRT("n bn to bin overflow!\n");
		goto gen_fail;
	}

	if (wcrypto_set_rsa_pubkey_params(ctx, &wd_e, &wd_n))
	{
		HPRE_TST_PRT("set rsa pubkey failed %d!\n", ret);
		goto gen_fail;
	}

	if (pubkey_file && is_file) {
		ret = hpre_test_write_to_file((unsigned char *)wd_e.data, key_bits >> 2,
					  pubkey_file, -1, 1);
		if (ret < 0)
			goto gen_fail;
		HPRE_TST_PRT("RSA public key was written to %s!\n",
					 privkey_file);
	}

	if (rsa_key_in) {
		memset(rsa_key_in->e, 0, key_size);
		memset(rsa_key_in->p, 0, key_size >> 1);
		memset(rsa_key_in->q, 0, key_size >> 1);
		rsa_key_in->e_size = BN_bn2bin(e, (unsigned char *)rsa_key_in->e);
		rsa_key_in->p_size = BN_bn2bin(p, (unsigned char *)rsa_key_in->p);
		rsa_key_in->q_size = BN_bn2bin(q, (unsigned char *)rsa_key_in->q);
	}

	//wcrypto_get_rsa_prikey(ctx, &prikey);

	if (wcrypto_rsa_is_crt(ctx)) {
		//wcrypto_get_rsa_crt_prikey_params(prikey, &wd_dq, &wd_dp, &wd_qinv, &wd_q, &wd_p);
		wd_dq.bsize = CRT_PARAM_SZ(key_size);
		wd_dq.data = malloc(CRT_PARAMS_SZ(key_size));
		wd_dp.bsize = CRT_PARAM_SZ(key_size);
		wd_dp.data = wd_dq.data + wd_dq.bsize;
		wd_qinv.bsize = CRT_PARAM_SZ(key_size);
		wd_qinv.data = wd_dp.data + wd_dp.bsize;
		wd_q.bsize = CRT_PARAM_SZ(key_size);
		wd_q.data = wd_qinv.data + wd_qinv.bsize;
		wd_p.bsize = CRT_PARAM_SZ(key_size);
		wd_p.data = wd_q.data + wd_q.bsize;


		/* CRT mode private key */
		wd_dq.dsize = BN_bn2bin(dmq1, (unsigned char *)wd_dq.data);
		if (wd_dq.dsize > wd_dq.bsize) {
			HPRE_TST_PRT("dq bn to bin overflow!\n");
			goto gen_fail;
		}
		wd_dp.dsize = BN_bn2bin(dmp1, (unsigned char *)wd_dp.data);
		if (wd_dp.dsize > wd_dp.bsize) {
			HPRE_TST_PRT("dp bn to bin overflow!\n");
			goto gen_fail;
		}
		wd_q.dsize = BN_bn2bin(q, (unsigned char *)wd_q.data);
		if (wd_q.dsize > wd_q.bsize) {
			HPRE_TST_PRT("q bn to bin overflow!\n");
			goto gen_fail;
		}
		wd_p.dsize = BN_bn2bin(p, (unsigned char *)wd_p.data);
		if (wd_p.dsize > wd_p.bsize) {
			HPRE_TST_PRT("p bn to bin overflow!\n");
			goto gen_fail;
		}
		wd_qinv.dsize = BN_bn2bin(iqmp, (unsigned char *)wd_qinv.data);
		if (wd_qinv.dsize > wd_qinv.bsize) {
			HPRE_TST_PRT("qinv bn to bin overflow!\n");
			goto gen_fail;
		}

		if (wcrypto_set_rsa_crt_prikey_params(ctx, &wd_dq,
					&wd_dp, &wd_qinv,
					&wd_q, &wd_p))
		{
			HPRE_TST_PRT("set rsa crt prikey failed %d!\n", ret);
			goto gen_fail;
		}

		if (crt_privkey_file && is_file) {
			ret = hpre_test_write_to_file((unsigned char *)wd_dq.data,
						  (key_bits >> 4) * 5, crt_privkey_file, -1, 0);
			if (ret < 0)
				goto gen_fail;
			ret = hpre_test_write_to_file((unsigned char *)wd_e.data,
						  (key_bits >> 2), crt_privkey_file, ret, 1);
			if (ret < 0)
				goto gen_fail;
			HPRE_TST_PRT("RSA CRT private key was written to %s!\n",
						 crt_privkey_file);
		} else if (crt_privkey_file && !is_file) {
			memcpy(crt_privkey_file, wd_dq.data, (key_bits >> 4) * 5);
			memcpy(crt_privkey_file + (key_bits >> 4) * 5,
				   wd_e.data, (key_bits >> 2));
		}

	} else {
		//wcrypto_get_rsa_prikey_params(prikey, &wd_d, &wd_n);
			wd_d.bsize = key_size;
			wd_d.data = malloc(GEN_PARAMS_SZ(key_size));
			wd_n.bsize =key_size;
			wd_n.data = wd_d.data + wd_d.bsize;

			/* common mode private key */
			wd_d.dsize = BN_bn2bin(d, (unsigned char *)wd_d.data);
			wd_n.dsize = BN_bn2bin(n, (unsigned char *)wd_n.data);

			if (wcrypto_set_rsa_prikey_params(ctx, &wd_d, &wd_n))
			{
				HPRE_TST_PRT("set rsa prikey failed %d!\n", ret);
				goto gen_fail;
			}

			if (privkey_file && is_file) {
				ret = hpre_test_write_to_file((unsigned char *)wd_d.data,
							  (key_size),
							  privkey_file, -1, 0);
				if (ret < 0)
					goto gen_fail;
				ret = hpre_test_write_to_file((unsigned char *)wd_n.data,
							  (key_size),
							  privkey_file, ret, 1);
				if (ret < 0)
					goto gen_fail;

				ret = hpre_test_write_to_file((unsigned char *)wd_e.data,
							  (key_size), privkey_file, ret, 1);
				if (ret < 0)
					goto gen_fail;
				HPRE_TST_PRT("RSA common private key was written to %s!\n",
							 privkey_file);
			} else if (privkey_file && !is_file) {
				memcpy(privkey_file, wd_d.data, key_size);
				memcpy(privkey_file + key_size, wd_n.data, key_size);
				memcpy(privkey_file + 2 * key_size, wd_e.data, key_size);
			}
	}

	RSA_free(test_rsa);
	BN_free(e_value);

	if (wd_e.data)
		free(wd_e.data);

	if (wcrypto_rsa_is_crt(ctx)) {
		if (wd_dq.data)
			free(wd_dq.data);
	} else {
		if (wd_d.data)
			free(wd_d.data);
	}

	return 0;
gen_fail:
	RSA_free(test_rsa);
	BN_free(e_value);

	if (wd_e.data)
		free(wd_e.data);

	if (wcrypto_rsa_is_crt(ctx)) {
		if (wd_dq.data)
			free(wd_dq.data);
	} else {
		if (wd_d.data)
			free(wd_d.data);
	}

	return ret;
}

int hpre_test_fill_keygen_opdata(void *ctx, struct wcrypto_rsa_op_data *opdata)
{
	struct wd_dtb *e, *p, *q;
	struct wcrypto_rsa_pubkey *pubkey;
	struct wcrypto_rsa_prikey *prikey;
	struct wd_dtb t_e, t_p, t_q;

	wcrypto_get_rsa_pubkey(ctx, &pubkey);
	wcrypto_get_rsa_pubkey_params(pubkey, &e, NULL);
	wcrypto_get_rsa_prikey(ctx, &prikey);

	if (wcrypto_rsa_is_crt(ctx)) {
		wcrypto_get_rsa_crt_prikey_params(prikey, NULL , NULL, NULL, &q, &p);
	} else {
		e = &t_e;
		p = &t_p;
		q = &t_q;
		e->data = rsa_key_in->e;
		e->dsize = rsa_key_in->e_size;
		p->data = rsa_key_in->p;
		p->dsize = rsa_key_in->p_size;
		q->data = rsa_key_in->q;
		q->dsize = rsa_key_in->q_size;
	}

	opdata->in = wcrypto_new_kg_in(ctx, e, p, q);
	if (!opdata->in) {
		HPRE_TST_PRT("create rsa kgen in fail!\n");
		return -ENOMEM;
	}
	opdata->out = wcrypto_new_kg_out(ctx);
	if (!opdata->out) {
		HPRE_TST_PRT("create rsa kgen out fail!\n");
		return -ENOMEM;
	}
	return 0;
}

static int hpre_test_get_bin_size(__u8 *bin, int csize)
{
	int i = csize - 1;
	int cut = 0;

	while (!(*(__u8 *)(bin + i)) && i >= 0) {
		i--;
		cut++;
	}

	return csize - cut;
}

static BIGNUM *hpre_bin_to_bn(void *bin, int raw_size)
{
	int bin_size;

	if (!bin || !raw_size)
		return NULL;
	bin_size = hpre_test_get_bin_size((__u8 *)bin, raw_size);
	return BN_bin2bn((const unsigned char *)bin, bin_size, NULL);
}

int hpre_test_result_check(void *ctx,  struct wcrypto_rsa_op_data *opdata, void *key)
{
	struct wcrypto_rsa_kg_out *out = (void *)opdata->out;
	struct wcrypto_rsa_prikey *prikey;
	int ret, keybits, key_size;
	void *ssl_out;
	BIGNUM *nn;
	BIGNUM *e;

	if (!hpre_test_rsa) {
		hpre_test_rsa = RSA_new();
		if (!hpre_test_rsa) {
			HPRE_TST_PRT("%s:RSA new fail!\n", __func__);
			return -ENOMEM;
		}
	}
	wcrypto_get_rsa_prikey(ctx, &prikey);
	keybits = wcrypto_rsa_key_bits(ctx);
	key_size = keybits >> 3;
	if (opdata->op_type == WCRYPTO_RSA_GENKEY) {
		if (wcrypto_rsa_is_crt(ctx)) {
			struct wd_dtb qinv, dq, dp;
			struct wd_dtb *s_qinv, *s_dq, *s_dp;

			wcrypto_get_rsa_crt_prikey_params(prikey, &s_dq, &s_dp,
							&s_qinv, NULL, NULL);
			wcrypto_get_rsa_kg_out_crt_params(out, &qinv, &dq, &dp);

			if (memcmp(s_qinv->data, qinv.data, s_qinv->bsize)) {
				HPRE_TST_PRT("keygen  qinv  mismatch!\n");
				return -EINVAL;
			}
			if (memcmp(s_dq->data, dq.data, s_dq->bsize)) {
				HPRE_TST_PRT("keygen  dq mismatch!\n");
				return -EINVAL;
			}
			if (memcmp(s_dp->data, dp.data, s_dp->bsize)) {
				HPRE_TST_PRT("keygen  dp  mismatch!\n");
				return -EINVAL;
			}
		} else {
			struct wd_dtb d, n;
			struct wd_dtb *s_d, *s_n;

			wcrypto_get_rsa_kg_out_params(out, &d, &n);

			wcrypto_get_rsa_prikey_params(prikey, &s_d, &s_n);

			/* check D */
			if (memcmp(s_n->data, n.data, s_n->bsize)) {
				HPRE_TST_PRT("key generate N result mismatching!\n");
				return -EINVAL;
			}
			if (memcmp(s_d->data, d.data, s_d->bsize)) {
				HPRE_TST_PRT("key generate D result mismatching!\n");
				return -EINVAL;
			}
		}
	} else if (opdata->op_type == WCRYPTO_RSA_VERIFY) {
		ssl_out = malloc(key_size);
		if (!ssl_out) {
			HPRE_TST_PRT("malloc ssl out fail!\n");
			return -ENOMEM;
		}
		if (key) {
			nn = hpre_bin_to_bn(key + key_size,
					    key_size);
			if (!nn) {
				HPRE_TST_PRT("n bin2bn err!\n");
				return -EINVAL;
			}
			e = hpre_bin_to_bn(key, key_size);
			if (!e) {
				HPRE_TST_PRT("e bin2bn err!\n");
				return -EINVAL;
			}
			ret = RSA_set0_key(hpre_test_rsa, nn, e, NULL);
			if (ret <= 0) {
				HPRE_TST_PRT("e set0_key err!\n");
				return -EINVAL;
			}
		}
		ret = RSA_public_encrypt(opdata->in_bytes, opdata->in, ssl_out,
					 hpre_test_rsa, RSA_NO_PADDING);
		if (ret != (int)opdata->in_bytes) {
			HPRE_TST_PRT("openssl pub encrypto fail!ret=%d\n", ret);
			return -ENOMEM;
		}
		if (!only_soft && memcmp(ssl_out, opdata->out, key_size)) {
			HPRE_TST_PRT("pub encrypto result  mismatch!\n");
			return -EINVAL;
		}
		free(ssl_out);
	} else {
		ssl_out = malloc(key_size);
		if (!ssl_out) {
			HPRE_TST_PRT("malloc ssl out fail!\n");
			return -ENOMEM;
		}
		if (key && wcrypto_rsa_is_crt(ctx)) {
			BIGNUM *dp, *dq, *iqmp, *p, *q;
			int size = key_size / 2;

			dq = hpre_bin_to_bn(key, size);
			if (!dq) {
				HPRE_TST_PRT("dq bin2bn err!\n");
				return -EINVAL;
			}
			dp = hpre_bin_to_bn(key + size, size);
			if (!dp) {
				HPRE_TST_PRT("dp bin2bn err!\n");
				return -EINVAL;
			}
			q = hpre_bin_to_bn(key + 2 * size, size);
			if (!q) {
				HPRE_TST_PRT("q bin2bn err!\n");
				return -EINVAL;
			}
			p = hpre_bin_to_bn(key + 3 * size, size);
			if (!p) {
				HPRE_TST_PRT("p bin2bn err!\n");
				return -EINVAL;
			}
			iqmp = hpre_bin_to_bn(key + 4 * size, size);
			if (!iqmp) {
				HPRE_TST_PRT("iqmp bin2bn err!\n");
				return -EINVAL;
			}
			ret = RSA_set0_crt_params(hpre_test_rsa, dp, dq, iqmp);
			if (ret <= 0) {
				HPRE_TST_PRT("set0_crt_params err!\n");
				return -EINVAL;
			}
			ret = RSA_set0_factors(hpre_test_rsa, p, q);
			if (ret <= 0) {
				HPRE_TST_PRT("set0_factors err!\n");
				return -EINVAL;
			}
			nn = hpre_bin_to_bn(key + 7 * size, key_size);
			if (!nn) {
				HPRE_TST_PRT("n bin2bn err!\n");
				return -EINVAL;
			}
			e = hpre_bin_to_bn(key + 5 * size, key_size);
			if (!e) {
				HPRE_TST_PRT("e bin2bn err!\n");
				return -EINVAL;
			}
			ret = RSA_set0_key(hpre_test_rsa, nn, e, NULL);
			if (ret <= 0) {
				HPRE_TST_PRT("rsa set0_key crt err!\n");
				return -EINVAL;
			}
		} else if (key && !wcrypto_rsa_is_crt(ctx)) {
			BIGNUM *d;

			nn = hpre_bin_to_bn(key + key_size, key_size);
			if (!nn) {
				HPRE_TST_PRT("n bin2bn err!\n");
				return -EINVAL;
			}
			d = hpre_bin_to_bn(key, key_size);
			if (!d) {
				HPRE_TST_PRT("d bin2bn err!\n");
				return -EINVAL;
			}
			e = hpre_bin_to_bn(key + 2 * key_size, key_size);
			if (!e) {
				HPRE_TST_PRT("e bin2bn err!\n");
				return -EINVAL;
			}
			ret = RSA_set0_key(hpre_test_rsa, nn, e, d);
			if (ret <= 0) {
				HPRE_TST_PRT("d set0_key err!\n");
				return -EINVAL;
			}
		}
		ret = RSA_private_decrypt(opdata->in_bytes, opdata->in, ssl_out,
					hpre_test_rsa, RSA_NO_PADDING);
		if (ret != (int)opdata->in_bytes) {
			HPRE_TST_PRT("openssl priv decrypto fail!ret=%d\n", ret);
			return -ENOMEM;
		}
#ifdef DEBUG
		print_data(opdata->out, 16, "out");
		print_data(opdata->in, 16, "in");
		print_data(ssl_out, 16, "ssl_out");
#endif
		if (!only_soft && memcmp(ssl_out, opdata->out, ret)) {
			HPRE_TST_PRT("prv decrypto result  mismatch!\n");
			return -EINVAL;
		}
		free(ssl_out);
	}

	return 0;
}

int hpre_dh_test(void *c, struct hpre_queue_mempool *pool)
{
	DH *a = NULL, *b = NULL;
	int ret, generator = DH_GENERATOR_5;
	struct wcrypto_dh_op_data opdata_a;
	struct wcrypto_dh_op_data opdata_b;
	const BIGNUM *ap = NULL, *ag = NULL,
			*apub_key = NULL, *apriv_key = NULL;
	const BIGNUM *bp = NULL, *bg = NULL,
			*bpub_key = NULL, *bpriv_key = NULL;
	unsigned char *ap_bin = NULL, *ag_bin = NULL,
			*apub_key_bin = NULL, *apriv_key_bin = NULL;
	unsigned char *bp_bin = NULL, *bg_bin = NULL,
			*bpub_key_bin = NULL, *bpriv_key_bin = NULL;
	unsigned char *abuf = NULL;
	struct wd_dtb g;

	__u32 gbytes;
	void *tag = NULL;
	int key_size, key_bits, bin_size = 0;

	if (!pool) {
		HPRE_TST_PRT("pool null!\n");
		return -1;
	}

	a = DH_new();
	b = DH_new();
	if (!a || !b) {
		HPRE_TST_PRT("New DH fail!\n");
		return -1;
	}
	if (wcrypto_dh_is_g2(c))
		generator = DH_GENERATOR_2;

	key_bits = wcrypto_dh_key_bits(c);
	key_size = key_bits >> 3;

	/* Alice generates DH parameters */
	ret = DH_generate_parameters_ex(a, key_bits, generator, NULL);
	if (!ret) {
		HPRE_TST_PRT("DH_generate_parameters_ex fail!\n");
		goto dh_err;
	}
	DH_get0_pqg(a, &ap, NULL, &ag);
	bp = BN_dup(ap);
	bg = BN_dup(ag);
	if (!bp || !bg) {
		HPRE_TST_PRT("bn dump fail!\n");
		ret = -1;
		goto dh_err;
	}

	/* Set the same parameters on Bob as Alice :) */
	DH_set0_pqg(b, (BIGNUM *)bp, NULL, (BIGNUM *)bg);
	if (!DH_generate_key(a)) {
		HPRE_TST_PRT("a DH_generate_key fail!\n");
		ret = -1;
		goto dh_err;
	}
	DH_get0_key(a, &apub_key, &apriv_key);
	ag_bin = wd_alloc_blk(pool);
	if (!ag_bin) {
		HPRE_TST_PRT("pool alloc ag_bin fail!\n");
		goto dh_err;
	}
	memset(ag_bin, 0, key_size * 2);
	apriv_key_bin = wd_alloc_blk(pool);
	if (!apriv_key_bin) {
		HPRE_TST_PRT("pool alloc apriv_key_bin fail!\n");
		goto dh_err;
	}
	memset(apriv_key_bin, 0, key_size * 2);

	/* The hpre_UM tells us key_addr contains xa and p,
	 * their addr should be together
	 */
	ap_bin= apriv_key_bin + key_size;

	gbytes = BN_bn2bin(ag, ag_bin);
	g.data = (char*)ag_bin;
	g.bsize = key_size;
	g.dsize = gbytes;
	opdata_a.pbytes = BN_bn2bin(ap, ap_bin);
	opdata_a.xbytes = BN_bn2bin(apriv_key, apriv_key_bin);
	ret = wcrypto_set_dh_g(c, &g);
	if (ret) {
		HPRE_TST_PRT("Alice wcrypto_set_dh_g fail!\n");
		goto dh_err;
	}
	opdata_a.x_p = apriv_key_bin;
	opdata_a.pri = wd_alloc_blk(pool);
	if (!opdata_a.pri) {
		HPRE_TST_PRT("pool alloc opdata_a.pri fail!\n");
		goto dh_err;
	}
	memset(opdata_a.pri, 0, key_size * 2);

	opdata_a.op_type = WCRYPTO_DH_PHASE1;

	/* Alice computes public key */
	ret = wcrypto_do_dh(c, &opdata_a, tag);
	if (ret) {
		HPRE_TST_PRT("a wcrypto_do_dh fail!\n");
		goto dh_err;
	}

	if (openssl_check) {
		apub_key_bin = malloc(key_size);
		if (!apub_key_bin) {
			HPRE_TST_PRT("malloc apub_key_bin fail!\n");
			ret = -ENOMEM;
			goto dh_err;
		}
		ret = BN_bn2bin(apub_key, apub_key_bin);
		if (!ret) {
			HPRE_TST_PRT("apub_key bn 2 bin fail!\n");
			ret = -1;
			goto dh_err;
		}
		bin_size = ret;

		if (memcmp(apub_key_bin, opdata_a.pri, bin_size)) {
			HPRE_TST_PRT("Alice HPRE DH key gen pub mismatch, dsize %d!\n", bin_size);
			ret = -EINVAL;
#ifdef DEBUG
			print_data(apub_key_bin, key_size, "SOFT");
			print_data(opdata_a.pri, key_size, "HARDWATE");
#endif
			goto dh_err;
		}
	}
	if (!DH_generate_key(b)) {
		HPRE_TST_PRT("b DH_generate_key fail!\n");
		ret = -1;
		goto dh_err;
	}
	DH_get0_key(b, &bpub_key, &bpriv_key);
	bg_bin = wd_alloc_blk(pool);
	if (!bg_bin) {
		HPRE_TST_PRT("pool alloc bg_bin fail!\n");
		ret = -1;
		goto dh_err;
	}
	memset(bg_bin, 0, key_size * 2);

	bpriv_key_bin= wd_alloc_blk(pool);
	if (!bpriv_key_bin) {
		HPRE_TST_PRT("pool alloc bpriv_key_bin fail!\n");
		ret = -1;
		goto dh_err;
	}
	memset(bpriv_key_bin, 0, key_size * 2);
	bp_bin = bpriv_key_bin + key_size;
	gbytes = BN_bn2bin(bg, bg_bin);
	g.data = (char*)bg_bin;
	g.bsize = gbytes;
	g.dsize = key_size;
	ret = wcrypto_set_dh_g(c, &g);
	if (ret) {
		HPRE_TST_PRT("bob wcrypto_set_dh_g fail!\n");
		goto dh_err;
	}
	opdata_b.pbytes = BN_bn2bin(bp, bp_bin);
	opdata_b.xbytes = BN_bn2bin(bpriv_key, bpriv_key_bin);
	opdata_b.x_p = bpriv_key_bin;
	opdata_b.pri = wd_alloc_blk(pool);
	if (!opdata_b.pri) {
		HPRE_TST_PRT("pool alloc opdata_b.pri fail!\n");
		ret = -1;
		goto dh_err;
	}
	memset(opdata_b.pri, 0, key_size * 2);
	opdata_b.op_type = WCRYPTO_DH_PHASE1;

	/* Bob computes public key */
	ret = wcrypto_do_dh(c, &opdata_b, tag);
	if (ret) {
		HPRE_TST_PRT("b wcrypto_do_dh fail!\n");
		goto dh_err;
	}
	if (openssl_check) {
		bpub_key_bin = malloc(key_size);
		if (!bpub_key_bin) {
			HPRE_TST_PRT("malloc bpub_key_bin fail!\n");
			ret = -1;
			goto dh_err;
		}
		ret = BN_bn2bin(bpub_key, bpub_key_bin);
		if (!ret) {
			HPRE_TST_PRT("bpub_key bn 2 bin fail!\n");
			goto dh_err;
		}
		bin_size = ret;

		if (memcmp(bpub_key_bin, opdata_b.pri, bin_size)) {
			HPRE_TST_PRT("Bob HPRE DH key gen pub mismatch, dsize %d!\n", bin_size);
			ret = -EINVAL;
#ifdef DEBUG
			print_data(bpub_key_bin, key_size, "SOFT");
			print_data(opdata_b.pri, key_size, "HARDWATE");
#endif
			goto dh_err;
		}
	}
	/* Alice computes private key with OpenSSL */
	abuf = malloc(key_size);
	if (!abuf) {
		HPRE_TST_PRT("malloc abuf fail!\n");
		ret = -ENOMEM;
		goto dh_err;
	}

	memset(abuf, 0, key_size);
	if (openssl_check) {
		ret = DH_compute_key(abuf, bpub_key, a);
		if (!ret) {
			HPRE_TST_PRT("DH_compute_key fail!\n");
			ret = -1;
			goto dh_err;
		}
		bin_size = ret;
	}

	/* Alice computes private key with HW accelerator */
	memset(ag_bin, 0, key_size * 2);
	memset(apriv_key_bin, 0, key_size * 2);
	ap_bin = apriv_key_bin + key_size;
	memset(opdata_a.pri, 0, key_size * 2);

	opdata_a.pvbytes = BN_bn2bin(bpub_key, ag_bin);
	opdata_a.pv = ag_bin;/* bob's public key here */
	opdata_a.pbytes = BN_bn2bin(ap, ap_bin);
	opdata_a.xbytes = BN_bn2bin(apriv_key, apriv_key_bin);
	opdata_a.x_p = apriv_key_bin;
	opdata_a.pri = wd_alloc_blk(pool);
	if (!opdata_a.pri) {
		HPRE_TST_PRT("pool alloc opdata_a.pri fail!\n");
		ret = -1;
		goto dh_err;
	}
	memset(opdata_a.pri, 0, key_size * 2);
	opdata_a.op_type = WCRYPTO_DH_PHASE2;

	/* Alice computes private key with HPRE */
	ret = wcrypto_do_dh(c, &opdata_a, tag);
	if (ret) {
		HPRE_TST_PRT("a wcrypto_do_dh fail!\n");
		goto dh_err;
	}
	if (openssl_check) {
		if (memcmp(abuf, opdata_a.pri, bin_size)) {
			HPRE_TST_PRT("Alice HPRE DH gen privkey mismatch!\n");
			ret = -EINVAL;
#ifdef DEBUG
			print_data(abuf, key_size, "SOFT");
			print_data(opdata_a.pri, key_size, "HARDWATE");
#endif
			goto dh_err;
		}
	}

	ret = 0;
	HPRE_TST_PRT("HPRE DH generate key sucessfully!\n");
	dh_err:
	DH_free(a);
	DH_free(b);
	if (ag_bin)
		wd_free_blk(pool, ag_bin);
	if (apriv_key_bin)
		wd_free_blk(pool, apriv_key_bin);
	if (opdata_a.pri)
		wd_free_blk(pool, opdata_a.pri);

	if (bg_bin)
		wd_free_blk(pool, bg_bin);
	if (bpriv_key_bin)
		wd_free_blk(pool, bpriv_key_bin);
	if (opdata_b.pri)
		wd_free_blk(pool, opdata_b.pri);

	if (apub_key_bin)
		free(apub_key_bin);
	if (bpub_key_bin)
		free(bpub_key_bin);
	if (abuf)
		free(abuf);
	return ret;
}

#ifdef RSA_OP_DEBUG
int hpre_test_rsa_op(enum alg_op_type op_type, void *c, __u8 *in,
		    int in_size,  __u8 *out,  __u8 *key)
{
	struct wcrypto_rsa_op_data opdata;
	int ret, shift;
	void *tag;
	int key_bits, key_size;

	key_bits =  wcrypto_dh_key_bits(c);
	key_size = key_bits >> 3;
	if (op_type == RSA_KEY_GEN) {
		/* use openSSL generate key and store them to files at first */
		ret = test_rsa_key_gen(c, (char *)in,
				      (char *)out, (char *)key, 1);
		if (ret < 0)
			return ret;
	} else {
		struct wcrypto_rsa_pubkey pubkey;
		struct wcrypto_rsa_prikey prvkey;

		if (!key)
			goto try_format_input;
		memset(&pubkey, 0, sizeof(pubkey));
		memset(&prvkey, 0, sizeof(prvkey));
		if (op_type == RSA_PUB_EN) {
			pubkey.e = key;
			pubkey.n = key + (key_bits >> 3);
			ret = wd_set_rsa_pubkey(c, &pubkey);
			if (ret) {
				HPRE_TST_PRT("wd_set_rsa_pubkey fail!\n");
				return ret;
			}
		}
		if (op_type == RSA_PRV_DE && wcrypto_rsa_is_crt(c)) {
			prvkey.pkey2.dq = key;
			prvkey.pkey2.dp = key + (key_bits >> 4);
			prvkey.pkey2.q = key + (key_bits >> 3);
			prvkey.pkey2.p = key + (key_bits >> 4) * 3;
			prvkey.pkey2.qinv = key + (key_bits >> 2);
			ret = wd_set_rsa_prikey(c, &prvkey);
			if (ret) {
				HPRE_TST_PRT("wd_set_rsa_prikey crt fail!\n");
				return ret;
			}
		} else if (op_type == RSA_PRV_DE && !wcrypto_rsa_is_crt(c)) {
			prvkey.pkey1.d = key;
			prvkey.pkey1.n = key + (key_bits >> 3);
			ret = wd_set_rsa_prikey(c, &prvkey);
			if (ret) {
				HPRE_TST_PRT("wd_set_rsa_prikey fail!\n");
				return ret;
			}
		}
try_format_input:
		/* Padding zero in this sample */
		if (in_size < key_size && op_type == RSA_PUB_EN) {
			shift =  key_size - in_size;
			memmove(in + shift, in, in_size);
			memset(in, 0, shift);
		}
	}

	/* always key size bytes input */
	opdata.in_bytes = key_size;
	if (op_type == RSA_PRV_DE) {
		opdata.op_type = WCRYPTO_RSA_SIGN;
	} else if (op_type == RSA_PUB_EN) {
		opdata.op_type = WCRYPTO_RSA_VERIFY;
	} else if (op_type == RSA_KEY_GEN) {
		opdata.op_type = WCRYPTO_RSA_GENKEY;
	} else {
		ret = -EINVAL;
		goto type_err;
	}
	if (op_type == RSA_KEY_GEN) {
		ret = hpre_test_fill_keygen_opdata(c, &opdata);
		if (ret)
			goto type_err;
	} else {
		opdata.in = in;
		opdata.out = out;
	}
	tag = NULL;
	ret = wcrypto_do_rsa(c, &opdata, tag);
	if (ret)
		goto type_err;
	if (openssl_check) {
		ret = hpre_test_result_check(c, &opdata, key);
		if (ret)
			goto type_err;
		else if (opdata->op_type == WCRYPTO_RSA_GENKEY)
			HPRE_TST_PRT("HPRE hardware key generate successfully!\n");
	} else if (!openssl_check && op_type == RSA_KEY_GEN) {
		HPRE_TST_PRT("HPRE hardware key generate finished!\n");
	}
	if (op_type == RSA_PRV_DE) {
		__u8 *tmp = opdata.out;

		shift = 0;
		while (!tmp[shift])
			shift++;
		opdata.out_bytes -= shift;
		memmove(out, out + shift, opdata.out_bytes);
	}
	return (int)opdata.out_bytes;
type_err:
	return ret;
}
#endif

int hpre_sys_qmng_test(int thread_num)
{
	int pid = getpid(), i = 0, ret;
	int thread_id = (int)syscall(__NR_gettid);
	struct wd_queue q;

	memset((void *)&q, 0, sizeof(q));
	q.capa.alg = "rsa";

	while (1) {
		ret = wd_request_queue(&q);
		if (ret) {
			HPRE_TST_PRT("Proc-%d, thrd-%d:request queue t-%d fail!\n",
					 pid, thread_id, i);
			return ret;
		}
		i++;
		if (is_allow_print(i, HPRE_ALG_INVLD_TYPE, thread_num))
			HPRE_TST_PRT("Proc-%d, %d-TD request %dQs at %dnode\n",
				     pid, thread_id, i, wd_get_node_id(&q));
		usleep(1);
		wd_release_queue(&q);
	}
	return 0;
}

int hpre_sys_func_test(struct test_hpre_pthread_dt * pdata)
{
	int pid = getpid(), ret = 0, i = 0;
	int thread_id = (int)syscall(__NR_gettid);
	struct wcrypto_rsa_ctx_setup setup;
	struct wcrypto_rsa_op_data opdata;
	void *ctx = NULL;
	void *tag = NULL;
	struct wd_queue *q = pdata->q;
	void *key_info = NULL;
	struct timeval cur_tval;
	float time, speed;
	int key_size = key_bits >> 3;

	if (performance_test && (!t_times && !t_seconds)) {
		HPRE_TST_PRT("t_times or  t_seconds err\n");
		return -1;
	}

new_test_again:

	memset(&setup, 0, sizeof(setup));
	memset(&opdata, 0, sizeof(opdata));
	setup.key_bits = key_bits;
	setup.br.alloc = (void *)wd_alloc_blk;
	setup.br.free = (void *)wd_free_blk;
	setup.br.iova_map = (void *)wd_blk_iova_map;
	setup.br.iova_unmap = (void *)wd_blk_iova_unmap;
	setup.br.usr = pdata->pool;

	if (!strcmp(g_mode, "-crt"))
		setup.is_crt = true;
	else
		setup.is_crt = false;

	ctx = wcrypto_create_rsa_ctx(q, &setup);
	if (!ctx) {
		HPRE_TST_PRT("Proc-%d, %d-TD:create %s ctx fail!\n",
			     pid, thread_id, q->capa.alg);
		ret = -EINVAL;
		goto fail_release;
	}

	/* Just make sure memory size is enough */
	key_info = malloc(key_size * 16);
	if (!key_info) {
		HPRE_TST_PRT("thrd-%d:malloc key!\n", thread_id);
		goto fail_release;
	}

	rsa_key_in = malloc(2 * key_size + sizeof(struct hpre_rsa_test_key_in));
	if (!rsa_key_in) {
		HPRE_TST_PRT("thrd-%d:malloc err!\n", thread_id);
		goto fail_release;
	}

	rsa_key_in->e = rsa_key_in + 1;
	rsa_key_in->p = rsa_key_in->e + key_size;
	rsa_key_in->q = rsa_key_in->p + (key_size >> 1);

	memset(key_info, 0, key_size * 16);
	ret = test_rsa_key_gen(ctx, NULL, key_info, key_info, 0);
	if (ret) {
		HPRE_TST_PRT("thrd-%d:Openssl key gen fail!\n", thread_id);
		goto fail_release;
	}

	/* always key size bytes input */
	opdata.in_bytes = key_size;
	if (pdata->op_type == RSA_KEY_GEN) {
		opdata.op_type = WCRYPTO_RSA_GENKEY;
	} else if (pdata->op_type == RSA_PUB_EN) {
		opdata.op_type = WCRYPTO_RSA_VERIFY;
	} else if (pdata->op_type == RSA_PRV_DE) {
		opdata.op_type = WCRYPTO_RSA_SIGN;
	} else {
		HPRE_TST_PRT("thrd-%d:optype=%d err!\n",
			  thread_id, pdata->op_type);
		goto fail_release;
	}

	if (opdata.op_type == WCRYPTO_RSA_GENKEY) {
		ret = hpre_test_fill_keygen_opdata(ctx, &opdata);
		if (ret){
			HPRE_TST_PRT("fill key gen opdata fail!\n");
			goto fail_release;
		}
	} else {
		opdata.in = wd_alloc_blk(pdata->pool);
		if (!opdata.in) {
			HPRE_TST_PRT("alloc in buffer fail!\n");
			goto fail_release;
		}
		opdata.out = wd_alloc_blk(pdata->pool);
		if (!opdata.out) {
			HPRE_TST_PRT("alloc out buffer fail!\n");
			goto fail_release;
		}
	}

	do {
		if (!only_soft) {
			ret = wcrypto_do_rsa(ctx, &opdata, tag);
			if (ret || opdata.status) {
				HPRE_TST_PRT("Proc-%d, T-%d:hpre %s %dth status=%d fail!\n",
					 pid, thread_id,
					 rsa_op_str[opdata.op_type], i, opdata.status);
				goto fail_release;
			}
		}

		pdata->send_task_num++;
		i++;
		if (openssl_check) {
			void *check_key;

			if (opdata.op_type == WCRYPTO_RSA_SIGN)
				check_key = key_info;
			if (opdata.op_type == WCRYPTO_RSA_VERIFY)
				if (wcrypto_rsa_is_crt(ctx)) 
					check_key = key_info + 5 * (key_bits >> 4);
				else
					check_key = key_info;
			else
				check_key = key_info;
			ret = hpre_test_result_check(ctx, &opdata, check_key);
			if (ret) {
				HPRE_TST_PRT("P-%d,T-%d:hpre %s %dth mismth\n",
						 pid, thread_id,
						 rsa_op_str[opdata.op_type], i);
				goto fail_release;
			}	
			else {
				if (opdata.op_type == WCRYPTO_RSA_GENKEY) {
					if (is_allow_print(i, WCRYPTO_RSA_GENKEY,  pdata->thread_num)) 
						HPRE_TST_PRT("HPRE hardware key generate successfully!\n");
				}
			}
		}

		/* clean output buffer remainings in the last time operation */
		if (opdata.op_type == WCRYPTO_RSA_GENKEY) {
			char *data;
			int len;

			len = wcrypto_rsa_kg_out_data((void *)opdata.out, &data);
			if (len < 0) {
				HPRE_TST_PRT("wd rsa get key gen out data fail!\n");
				goto fail_release;
			}
			memset(data, 0, len);
		} else {
#ifdef DEBUG
			print_data(opdata.out, 16, "out");
#endif
		}
		if (is_allow_print(i, pdata->op_type, pdata->thread_num)) {
			gettimeofday(&cur_tval, NULL);
			time = (float)((cur_tval.tv_sec - pdata->start_tval.tv_sec) * 1000000 +
						   (cur_tval.tv_usec - pdata->start_tval.tv_usec));
			speed = 1 / (time / i) * 1000;
			HPRE_TST_PRT("Proc-%d, %d-TD %s %dtimes,%0.0fus, %0.3fkops\n",
					 pid, thread_id, rsa_op_str[opdata.op_type],
					 i, time, speed);
		}

		if (!performance_test && !only_soft) {
			if (opdata.op_type == WCRYPTO_RSA_GENKEY) {
				if (opdata.in)
					wcrypto_del_kg_in(ctx, opdata.in);
				if (opdata.out)
					wcrypto_del_kg_out(ctx, opdata.out);
			} else {
				if (opdata.in)
					wd_free_blk(pdata->pool, opdata.in);
				if (opdata.out)
					wd_free_blk(pdata->pool, opdata.out);
			}

			if (ctx)
				wcrypto_del_rsa_ctx(ctx);

			if (rsa_key_in)
				free(rsa_key_in);

			if (key_info)
				free(key_info);

			goto new_test_again;
		}
	}while(!is_exit(pdata));

	pdata->recv_task_num = pdata->send_task_num;

	if (performance_test) {
		gettimeofday(&cur_tval, NULL);
		time = (float)((cur_tval.tv_sec -pdata->start_tval.tv_sec) * 1000000 +
				cur_tval.tv_usec - pdata->start_tval.tv_usec);

		if (t_seconds) {
			speed = pdata->send_task_num / time * 1000000;
			HPRE_TST_PRT("Proc-%d, %d-TD: dh do %s send %u task, recv %u task, run %0.1f s at %0.3f ops\n",
				 pid, thread_id, rsa_op_str_perf[opdata.op_type],
				pdata->send_task_num, pdata->recv_task_num,
				time / 1000000, speed);
		} else if (t_times) {
			speed = 1 / (time / t_times) * 1000;
			HPRE_TST_PRT("\r\nPID(%d)-thread-%d:%s CRT mode %dbits %s time %0.0f us, pkt len ="
				" %d bytes, %0.3f Kops\n", getpid(), (int)syscall(__NR_gettid), "rsa",
				key_bits, rsa_op_str_perf[opdata.op_type], time, key_bits / 8, speed);
		}
	}

fail_release:
	if (opdata.op_type == WCRYPTO_RSA_GENKEY) {
		if (opdata.in)
			wcrypto_del_kg_in(ctx, opdata.in);
		if (opdata.out)
			wcrypto_del_kg_out(ctx, opdata.out);
	} else {
		if (opdata.in)
			wd_free_blk(pdata->pool, opdata.in);
		if (opdata.out)
			wd_free_blk(pdata->pool, opdata.out);
	}
	if (ctx)
		wcrypto_del_rsa_ctx(ctx);
	if (key_info)
		free(key_info);
	if (rsa_key_in)
		free(rsa_key_in);


	return ret;
}

void *_hpre_rsa_sys_test_thread(void *data)
{
	int ret, cpuid;
	struct test_hpre_pthread_dt *pdata = data;
	cpu_set_t mask;
	enum alg_op_type op_type;
	int thread_num;
	int pid = getpid();
	int thread_id = (int)syscall(__NR_gettid);

	CPU_ZERO(&mask);
	cpuid = pdata->cpu_id;
	op_type = pdata->op_type;
	thread_num = pdata->thread_num;
	CPU_SET(cpuid, &mask);
	if (cpuid) {
		ret = pthread_setaffinity_np(pthread_self(),
					 sizeof(mask), &mask);
		if (ret < 0) {
			HPRE_TST_PRT("Proc-%d, thrd-%d:set affinity fail!\n",
				 pid, thread_id);
			return NULL;
		}
		HPRE_TST_PRT("Proc-%d, thrd-%d bind to cpu-%d!\n",
				pid, thread_id, cpuid);
	}
	if (op_type == HPRE_ALG_INVLD_TYPE) {
		ret = hpre_sys_qmng_test(thread_num);
		if (ret)
			return NULL;
	} else {
		ret = hpre_sys_func_test(pdata);
		if (ret)
			return NULL;
	}
	return NULL;
}

static int hpre_sys_test(int thread_num, __u64 lcore_mask,
			 __u64 hcore_mask, enum alg_op_type op_type)
{
	void **pool;
	struct wd_blkpool_setup setup;
	int i, ret, cnt = 0, j;
	int block_num = 512;
	struct wd_queue *q;
	int h_cpuid, qidx;

	q = malloc(q_num * sizeof(struct wd_queue));
	if (!q) {
		HPRE_TST_PRT("malloc q memory fail!\n");
		return -ENOMEM;
	}
	memset(q, 0, q_num * sizeof(struct wd_queue));

	/* create pool for every queue */
	pool = malloc(q_num * sizeof(pool));
	if (!pool) {
		HPRE_TST_PRT("malloc pool memory fail!\n");
		return -ENOMEM;
	}

	memset(pool, 0, q_num * sizeof(pool));

	if (op_type != HPRE_ALG_INVLD_TYPE) {
		for (j = 0; j < q_num; j++) {
			if (op_type > MAX_RSA_ASYNC_TYPE && op_type < MAX_DH_TYPE)
				q[j].capa.alg = "dh";
			else
				q[j].capa.alg = "rsa";
			ret = wd_request_queue(&q[j]);
			if (ret) {
				HPRE_TST_PRT("request queue %d fail!\n", j);
				return ret;
			}
			memset(&setup, 0, sizeof(setup));
			if (!strncmp(q[j].capa.alg, "dh", 2))
				setup.block_size = key_bits >> 2;
			else if (!strncmp(q[j].capa.alg, "rsa", 3))
				setup.block_size = (key_bits >> 4) * 20;
			setup.block_num = block_num;
			setup.align_size = 64;

			pool[j] = wd_blkpool_create(&q[j], &setup);
			if (!pool[j]) {
				HPRE_TST_PRT("%s(): create %dth pool fail!\n", __func__, j);
				return -ENOMEM;
			}
		}
	}
	if (_get_one_bits(lcore_mask) > 0)
		cnt =  _get_one_bits(lcore_mask);
	else if (_get_one_bits(lcore_mask) == 0 &&
		 _get_one_bits(hcore_mask) == 0)
		cnt = thread_num;
	for (i = 0; i < cnt; i++) {
		qidx = i / ctx_num_per_q;
		test_thrds_data[i].pool = pool[qidx];
		test_thrds_data[i].q = &q[qidx];
		test_thrds_data[i].thread_num = thread_num;
		test_thrds_data[i].op_type = op_type;
		test_thrds_data[i].cpu_id = _get_cpu_id(i, lcore_mask);
		gettimeofday(&test_thrds_data[i].start_tval, NULL);
		ret = pthread_create(&system_test_thrds[i], NULL,
				    _hpre_sys_test_thread, &test_thrds_data[i]);
		if (ret) {
			HPRE_TST_PRT("Create %dth thread fail!\n", i);
			return ret;
		}
	}
	for (i = 0; i < thread_num - cnt; i++) {
		h_cpuid = _get_cpu_id(i, hcore_mask);
		if (h_cpuid > 0)
			h_cpuid += 64;

		qidx = (i + cnt) / ctx_num_per_q;
		test_thrds_data[i + cnt].pool = pool[qidx];
		test_thrds_data[i + cnt].q = &q[qidx];
		test_thrds_data[i + cnt].thread_num = thread_num;
		test_thrds_data[i + cnt].op_type = op_type;
		test_thrds_data[i + cnt].cpu_id = h_cpuid;
		gettimeofday(&test_thrds_data[i + cnt].start_tval, NULL);
		ret = pthread_create(&system_test_thrds[i + cnt], NULL,
				 _hpre_sys_test_thread, &test_thrds_data[i + cnt]);
		if (ret) {
			HPRE_TST_PRT("Create %dth thread fail!\n", i);
			return ret;
		}
	}
	for (i = 0; i < thread_num; i++) {
		ret = pthread_join(system_test_thrds[i], NULL);
		if (ret) {
			HPRE_TST_PRT("Join %dth thread fail!\n", i);
			return ret;
		}
	}

	return 0;
}

static void  *_rsa_async_poll_test_thread(void *data)
{
	struct test_hpre_pthread_dt *pdata = data;
	struct wd_queue *q = pdata->q;
	int ret;

	while (1) {
		ret = wcrypto_rsa_poll(q, 1);
		if (ret < 0) {
			break;
		}

		if (asyn_thread_exit)
			break;
	}

	return NULL;
}

static void _rsa_cb(void *message, void *rsa_tag)
{
	int keybits, key_size;
	struct rsa_async_tag *tag = rsa_tag;
	void *ctx = tag->ctx;
	int thread_id = tag->thread_id;
	int cnt = tag->cnt;
	struct wcrypto_rsa_msg *msg = message;
	void *out = msg->out;
	enum wcrypto_rsa_op_type  op_type = msg->op_type;
	struct wcrypto_rsa_prikey *prikey;
	struct test_hpre_pthread_dt *thread_info = tag->thread_info;

	wcrypto_get_rsa_prikey(ctx, &prikey);
	keybits = wcrypto_rsa_key_bits(ctx);
	key_size = keybits >> 3;

	if (op_type == WCRYPTO_RSA_GENKEY) {
		struct wcrypto_rsa_kg_out *kout = out;

		if (wcrypto_rsa_is_crt(ctx)) {
			struct wd_dtb qinv, dq, dp;
			struct wd_dtb *s_qinv, *s_dq, *s_dp;

			wcrypto_get_rsa_crt_prikey_params(prikey, &s_dq, &s_dp,
							&s_qinv, NULL, NULL);
			wcrypto_get_rsa_kg_out_crt_params(kout, &qinv, &dq, &dp);
			if (memcmp(s_qinv->data, qinv.data, s_qinv->bsize)) {
				HPRE_TST_PRT("keygen  qinv  mismatch!\n");
				return;
			}
			if (memcmp(s_dq->data, dq.data, s_dq->bsize)) {
				HPRE_TST_PRT("keygen  dq mismatch!\n");
				return;
			}
			if (memcmp(s_dp->data, dp.data, s_dp->bsize)) {
				HPRE_TST_PRT("keygen  dp  mismatch!\n");
				return;
			}

		} else {
			struct wd_dtb d, n;
			struct wd_dtb *s_d, *s_n;

			wcrypto_get_rsa_prikey_params(prikey, &s_d, &s_n);
			wcrypto_get_rsa_kg_out_params(kout, &d, &n);

			/* check D */
			if (memcmp(s_d->data, d.data, s_d->bsize)) {
				HPRE_TST_PRT("key generate D result mismatching!\n");
				return;
			}
			if (memcmp(s_n->data, n.data, s_n->bsize)) {
				HPRE_TST_PRT("key generate N result mismatching!\n");
				return;
			}
		}
		if (is_allow_print(cnt, DH_ASYNC_GEN, 1))
			HPRE_TST_PRT("HPRE hardware key generate successfully!\n");
	} else if (op_type == WCRYPTO_RSA_VERIFY) {
		if (!only_soft && memcmp(ssl_params.ssl_verify_result, out, key_size)) {
			HPRE_TST_PRT("pub encrypto result  mismatch!\n");
			return;
		}
	} else {
		if (wcrypto_rsa_is_crt(ctx))
			if (!only_soft && memcmp(ssl_params.ssl_sign_result, out, key_size)) {
				HPRE_TST_PRT("prv decrypto result  mismatch!\n");
				return;
			}
	}

	thread_info->recv_task_num++;

	if (is_allow_print(cnt, op_type, 1))
		HPRE_TST_PRT("thread %d do RSA %dth time success!\n", thread_id, cnt);
	free(rsa_tag);
}

void *_rsa_async_op_test_thread(void *data)
{
	int ret = 0, i = 0, cpuid;
	struct test_hpre_pthread_dt *pdata = data;
	cpu_set_t mask;
	enum alg_op_type op_type;
	int pid = getpid();
	int thread_id = (int)syscall(__NR_gettid);
	void *pool;
	struct wcrypto_rsa_ctx_setup setup;
	struct wcrypto_rsa_op_data opdata;
	void *ctx = NULL;
	struct wd_queue *q;
	void *key_info = NULL;
	struct wcrypto_rsa_prikey *prikey;
	struct wcrypto_rsa_pubkey *pubkey;
	struct rsa_async_tag *tag;
	struct wd_dtb *wd_e, *wd_d, *wd_n, *wd_dq, *wd_dp, *wd_qinv, *wd_q, *wd_p;
	struct wd_dtb t_e, t_p, t_q;
	u32 key_size = key_bits >> 3;

	if (performance_test && (!t_times && !t_seconds)) {
		HPRE_TST_PRT("t_times or  t_seconds err\n");
		return NULL;
	}

	CPU_ZERO(&mask);
	cpuid = pdata->cpu_id;
	op_type = pdata->op_type;
	q = pdata->q;
	pool = pdata->pool;
	CPU_SET(cpuid, &mask);
	if (cpuid) {
		ret = pthread_setaffinity_np(pthread_self(),
					 sizeof(mask), &mask);
		if (ret < 0) {
			HPRE_TST_PRT("Proc-%d, thrd-%d:set affinity fail!\n",
				 pid, thread_id);
			return NULL;
		}
		HPRE_TST_PRT("Proc-%d, thrd-%d bind to cpu-%d!\n",
				pid, thread_id, cpuid);
	}
	memset(&setup, 0, sizeof(setup));
	memset(&opdata, 0, sizeof(opdata));
	setup.key_bits = key_bits;
	setup.cb = (void *)_rsa_cb;
	setup.br.alloc = (void *)wd_alloc_blk;
	setup.br.free =  (void *)wd_free_blk;
	setup.br.iova_map = (void *)wd_blk_iova_map;
	setup.br.iova_unmap = (void *)wd_blk_iova_unmap;
	setup.br.usr = pool;
	if (!strcmp(g_mode, "-crt"))
		setup.is_crt = true;
	else
		setup.is_crt = false;

	ctx = wcrypto_create_rsa_ctx(q, &setup);
	if (!ctx) {
		HPRE_TST_PRT("Proc-%d, %d-TD:create %s ctx fail!\n",
			     pid, thread_id, q->capa.alg);
		goto fail_release;
	}

	rsa_key_in = malloc(2 * key_size + sizeof(struct hpre_rsa_test_key_in));
	if (!rsa_key_in) {
		HPRE_TST_PRT("thrd-%d:malloc err!\n", thread_id);
		goto fail_release;
	}

	rsa_key_in->e = rsa_key_in + 1;
	rsa_key_in->p = rsa_key_in->e + key_size;
	rsa_key_in->q = rsa_key_in->p + (key_size >> 1);

	wcrypto_get_rsa_pubkey(ctx, &pubkey);
	wcrypto_get_rsa_pubkey_params(pubkey, &wd_e, &wd_n);
	wd_e->dsize = BN_bn2bin(ssl_params.e, (unsigned char *)wd_e->data);
	if (wd_e->dsize > wd_e->bsize) {
		HPRE_TST_PRT("e bn to bin overflow!\n");
		goto fail_release;
	}
	wd_n->dsize = BN_bn2bin(ssl_params.n, (unsigned char *)wd_n->data);
	if (wd_n->dsize > wd_n->bsize) {
		HPRE_TST_PRT("n bn to bin overflow!\n");
		goto fail_release;
	}

	wcrypto_get_rsa_prikey(ctx, &prikey);
	if (wcrypto_rsa_is_crt(ctx)) {
		wcrypto_get_rsa_crt_prikey_params(prikey, &wd_dq, &wd_dp, &wd_qinv, &wd_q, &wd_p);
		/* CRT mode private key */
		wd_dq->dsize = BN_bn2bin(ssl_params.dq, (unsigned char *)wd_dq->data);
		if (wd_dq->dsize > wd_dq->bsize) {
			HPRE_TST_PRT("dq bn to bin overflow!\n");
			goto fail_release;
		}
		wd_dp->dsize = BN_bn2bin(ssl_params.dp, (unsigned char *)wd_dp->data);
		if (wd_dp->dsize > wd_dp->bsize) {
			HPRE_TST_PRT("dp bn to bin overflow!\n");
			goto fail_release;
		}
		wd_qinv->dsize = BN_bn2bin(ssl_params.qinv, (unsigned char *)wd_qinv->data);
		if (wd_qinv->dsize > wd_qinv->bsize) {
			HPRE_TST_PRT("qinv bn to bin overflow!\n");
			goto fail_release;
		}
		wd_q->dsize = BN_bn2bin(ssl_params.q, (unsigned char *)wd_q->data);
		if (wd_q->dsize > wd_q->bsize) {
			HPRE_TST_PRT("q bn to bin overflow!\n");
			goto fail_release;
		}
		wd_p->dsize = BN_bn2bin(ssl_params.p, (unsigned char *)wd_p->data);
		if (wd_p->dsize > wd_p->bsize) {
			HPRE_TST_PRT("p bn to bin overflow!\n");
			goto fail_release;
		}

	} else {
		wcrypto_get_rsa_prikey_params(prikey, &wd_d, &wd_n);

		wd_d->dsize = BN_bn2bin(ssl_params.d, (unsigned char *)wd_d->data);
		wd_n->dsize = BN_bn2bin(ssl_params.n, (unsigned char *)wd_n->data);
		wd_e = &t_e;
		wd_p = &t_p;
		wd_q = &t_q;
		memset(rsa_key_in->e, 0, key_size);
		memset(rsa_key_in->p, 0, key_size >> 1);
		memset(rsa_key_in->q, 0, key_size >> 1);
		rsa_key_in->e_size = BN_bn2bin(ssl_params.e, (unsigned char *)rsa_key_in->e);
		rsa_key_in->p_size = BN_bn2bin(ssl_params.p, (unsigned char *)rsa_key_in->p);
		rsa_key_in->q_size = BN_bn2bin(ssl_params.q, (unsigned char *)rsa_key_in->q);
		wd_e->data = rsa_key_in->e;
		wd_e->dsize = rsa_key_in->e_size;
		wd_p->data = rsa_key_in->p;
		wd_p->dsize = rsa_key_in->p_size;
		wd_q->data = rsa_key_in->q;
		wd_q->dsize = rsa_key_in->q_size;
	}

	/* always key size bytes input */
	opdata.in_bytes = key_size;
	if (op_type == RSA_KEY_GEN || op_type == RSA_ASYNC_GEN) {
		opdata.op_type = WCRYPTO_RSA_GENKEY;
	} else if (op_type == RSA_PUB_EN || op_type == RSA_ASYNC_EN) {
		opdata.op_type = WCRYPTO_RSA_VERIFY;
	} else if (op_type == RSA_PRV_DE || op_type == RSA_ASYNC_DE) {
		opdata.op_type = WCRYPTO_RSA_SIGN;
	} else {
		HPRE_TST_PRT("thrd-%d:optype=%d err!\n",
			  thread_id, op_type);
		goto fail_release;
	}

	if (opdata.op_type == WCRYPTO_RSA_GENKEY) {
		opdata.in = (__u8 *)wcrypto_new_kg_in(ctx, wd_e, wd_p, wd_q);
		if (!opdata.in) {
			HPRE_TST_PRT("thrd-%d:fill key gen opdata fail!\n",
				     thread_id);
			goto fail_release;
		}
		opdata.out = wcrypto_new_kg_out(ctx);
		if (!opdata.out) {
			HPRE_TST_PRT("create rsa kgen out fail!\n");
			goto fail_release;
		}
	} else {
		opdata.in = wd_alloc_blk(pool);
		if (!opdata.in) {
			HPRE_TST_PRT("alloc in buffer fail!\n");
			goto fail_release;
		}
		memset(opdata.in, 0, opdata.in_bytes);
		opdata.out = wd_alloc_blk(pool);
		if (!opdata.out) {
			HPRE_TST_PRT("alloc out buffer fail!\n");
			goto fail_release;
		}
		memset(opdata.out, 0, opdata.in_bytes);
	}

	do {
			/* set the user tag */
			tag = malloc(sizeof(*tag));
			if (!tag)
				goto fail_release;
			tag->ctx = ctx;
			tag->thread_id = thread_id;
			tag->cnt = i;
			tag->thread_info = pdata;
try_do_again:
			ret = wcrypto_do_rsa(ctx, &opdata, tag);
			if (ret == -WD_EBUSY) {
				usleep(100);
				goto try_do_again;
			} else if (ret) {
				HPRE_TST_PRT("Proc-%d, T-%d:hpre %s %dth fail!\n",
					 pid, thread_id,
					 rsa_op_str[opdata.op_type], i);
				goto fail_release;
			}
			//usleep(100);
			i++;
			pdata->send_task_num++;
	}while (!is_exit(pdata));

	if (performance_test) {
		struct timeval cur_tval;
		float speed = 0.0, time_used = 0.0;
		gettimeofday(&cur_tval, NULL);
		time_used = (float)((cur_tval.tv_sec -pdata->start_tval.tv_sec) * 1000000 +
				cur_tval.tv_usec - pdata->start_tval.tv_usec);

		if (t_seconds) {
			speed = pdata->recv_task_num / time_used * 1000000;
			HPRE_TST_PRT("Proc-%d, %d-TD: rsa do %s send %u task, recv %u task, run %0.1f s at %0.3f ops\n",
				 pid, thread_id, rsa_op_str[opdata.op_type],
				pdata->send_task_num, pdata->recv_task_num,
				time_used / 1000000, speed);
		} else if (t_times) {
			speed = 1 / (time_used / t_times) * 1000;
			HPRE_TST_PRT("\r\nPID(%d)-thread-%d:%s CRT mode %dbits %s time %0.0f us, pkt len ="
				" %d bytes, %0.3f Kops\n", getpid(), (int)syscall(__NR_gettid), "rsa",
				key_bits, rsa_op_str_perf[opdata.op_type], time_used, key_bits / 8, speed);
		}
	}

	/* wait for recv finish */
	while (pdata->send_task_num != pdata->recv_task_num)
		usleep(1000);


fail_release:
	if (opdata.op_type == WCRYPTO_RSA_GENKEY) {
		if (opdata.in)
			wcrypto_del_kg_in(ctx, opdata.in);
		if (opdata.out)
			wcrypto_del_kg_out(ctx, opdata.out);
	} else {
		if (opdata.in)
			wd_free_blk(pool, opdata.in);
		if (opdata.out)
			wd_free_blk(pool, opdata.out);
	}
	if (ctx)
		wcrypto_del_rsa_ctx(ctx);
	if (key_info)
		free(key_info);
	if (rsa_key_in)
		free(rsa_key_in);
	return NULL;
}

static int set_ssl_plantext(void)
{
	ssl_params.size = key_bits >> 3;
	ssl_params.plantext = malloc(ssl_params.size);
	if (!ssl_params.plantext)
		return -ENOMEM;
	memset(ssl_params.plantext, 0, ssl_params.size);
	return 0;
}

static int rsa_openssl_key_gen_for_async_test(void)
{
	int ret;

	ssl_params.rsa = RSA_new();
	if (!ssl_params.rsa) {
		HPRE_TST_PRT("RSA new fail!\n");
		return -ENOMEM;
	}
	ssl_params.e = BN_new();
	if (!ssl_params.e) {
		RSA_free(ssl_params.rsa);
		ssl_params.rsa = NULL;
		HPRE_TST_PRT("BN new e fail!\n");
		ret = -ENOMEM;
		goto gen_fail;
	}
	ret = BN_set_word(ssl_params.e, 65537);
	if (ret != 1) {
		HPRE_TST_PRT("BN_set_word fail!\n");
		ret = -1;
		goto gen_fail;
	}

	/* Generate OpenSSL SW rsa parameters */
	ret = RSA_generate_key_ex(ssl_params.rsa, key_bits, ssl_params.e, NULL);
	if (ret != 1) {
		HPRE_TST_PRT("RSA_generate_key_ex fail!\n");
		ret = -1;
		goto gen_fail;
	}
	RSA_get0_key((const RSA *)ssl_params.rsa, (const BIGNUM **)&ssl_params.n,
			 (const BIGNUM **)&ssl_params.e, (const BIGNUM **)&ssl_params.d);
	RSA_get0_factors((const RSA *)ssl_params.rsa, (const BIGNUM **)&ssl_params.p,
			 (const BIGNUM **)&ssl_params.q);
	RSA_get0_crt_params((const RSA *)ssl_params.rsa, (const BIGNUM **)&ssl_params.dp,
			(const BIGNUM **)&ssl_params.dq, (const BIGNUM **)&ssl_params.qinv);

	/* Generate OpenSSL SW rsa verify and sign standard result
	 * for check in the next tests
	 */
	ret = set_ssl_plantext();
	if (ret) {
		HPRE_TST_PRT("set ssl plantext fail!!\n");
		ret = -1;
		goto gen_fail;
	}
	ssl_params.ssl_verify_result = malloc(ssl_params.size);
	if (!ssl_params.ssl_verify_result) {
		HPRE_TST_PRT("malloc verify result buffer fail!!\n");
		ret = -1;
		goto gen_fail;
	}
	ret = RSA_public_encrypt(ssl_params.size, ssl_params.plantext,
				 ssl_params.ssl_verify_result,
				 ssl_params.rsa, RSA_NO_PADDING);
	if (ret != ssl_params.size) {
		HPRE_TST_PRT("openssl pub encrypto fail!ret=%d\n", ret);
		ret = -1;
		return ret;
	}
	ssl_params.ssl_sign_result = malloc(ssl_params.size);
	if (!ssl_params.ssl_sign_result) {
		HPRE_TST_PRT("malloc sign result buffer fail!!\n");
		ret = -1;
		goto gen_fail;
	}
	ret = RSA_private_decrypt(ssl_params.size, ssl_params.plantext,
				  ssl_params.ssl_sign_result,
				  ssl_params.rsa, RSA_NO_PADDING);
	if (ret != ssl_params.size) {
		HPRE_TST_PRT("openssl priv decrypto fail!ret=%d\n", ret);
		ret = -1;
		goto gen_fail;
	}

	return 0;
gen_fail:
	RSA_free(ssl_params.rsa);
	BN_free(ssl_params.e);
	if (ssl_params.plantext)
		free(ssl_params.plantext);
	if (ssl_params.ssl_verify_result)
		free(ssl_params.ssl_verify_result);
	if (ssl_params.ssl_sign_result)
		free(ssl_params.ssl_sign_result);
	return ret;
}

static int rsa_async_test(int thread_num, __u64 lcore_mask,
			 __u64 hcore_mask, enum alg_op_type op_type)
{
	unsigned int block_num = 512;
	void *pool;
	struct wd_blkpool_setup setup;
	struct wd_queue q;
	int ret = 0, cnt = 0, i;
	int h_cpuid;

	memset(&q, 0, sizeof(q));
	q.capa.alg = "rsa";
	ret = wd_request_queue(&q);
	if (ret) {
		HPRE_TST_PRT("%s:request queue fail!\n", __func__);
		return ret;
	}
	memset(&setup, 0, sizeof(setup));
	setup.block_size = (key_bits >> 4) * 20;
	setup.block_num = block_num;
	setup.align_size = 64;

	pool = wd_blkpool_create(&q, &setup);
	if (!pool) {
		HPRE_TST_PRT("%s(): create pool fail!\n", __func__);
		return -ENOMEM;
	}

	/* Create poll thread at first */
	test_thrds_data[0].pool = pool;
	test_thrds_data[0].q = &q;
	test_thrds_data[0].thread_num = 1;
	test_thrds_data[0].op_type = op_type;
	test_thrds_data[0].cpu_id = 0;
	ret = pthread_create(&system_test_thrds[0], NULL,
		_rsa_async_poll_test_thread, &test_thrds_data[0]);
	if (ret) {
		HPRE_TST_PRT("Create poll thread fail!\n");
		return ret;
	}

	ret = rsa_openssl_key_gen_for_async_test();
	if(ret) {
		HPRE_TST_PRT("openssl genkey for async thread test fail!");
		return 0;
	}

	if (_get_one_bits(lcore_mask) > 0)
		cnt =  _get_one_bits(lcore_mask);
	else if (_get_one_bits(lcore_mask) == 0 &&
		 _get_one_bits(hcore_mask) == 0)
		cnt = thread_num;
	for (i = 1; i <= cnt; i++) {
		test_thrds_data[i].pool = pool;
		test_thrds_data[i].q = &q;
		test_thrds_data[i].thread_num = thread_num;
		test_thrds_data[i].op_type = op_type;
		test_thrds_data[i].cpu_id = _get_cpu_id(i - 1, lcore_mask);
		gettimeofday(&test_thrds_data[i].start_tval, NULL);
		ret = pthread_create(&system_test_thrds[i], NULL,
				    _rsa_async_op_test_thread, &test_thrds_data[i]);
		if (ret) {
			HPRE_TST_PRT("Create %dth thread fail!\n", i);
			return ret;
		}
	}
	for (i = 1; i <= thread_num - cnt; i++) {
		h_cpuid = _get_cpu_id(i - 1, hcore_mask);
		if (h_cpuid > 0)
			h_cpuid += 64;
		test_thrds_data[i + cnt].pool = pool;
		test_thrds_data[i + cnt].q = &q;
		test_thrds_data[i + cnt].thread_num = thread_num;
		test_thrds_data[i + cnt].op_type = op_type;
		test_thrds_data[i + cnt].cpu_id = h_cpuid;
		gettimeofday(&test_thrds_data[i + cnt].start_tval, NULL);
		ret = pthread_create(&system_test_thrds[i + cnt], NULL,
				 _rsa_async_op_test_thread, &test_thrds_data[i + cnt]);
		if (ret) {
			HPRE_TST_PRT("Create %dth thread fail!\n", i);
			return ret;
		}
	}
	for (i = 1; i <= thread_num; i++) {
		ret = pthread_join(system_test_thrds[i], NULL);
		if (ret) {
			HPRE_TST_PRT("Join %dth thread fail!\n", i);
			return ret;
		}
	}

	asyn_thread_exit = 1;

	ret = pthread_join(system_test_thrds[0], NULL);
	if (ret) {
		HPRE_TST_PRT("Join %dth thread fail!\n", i);
		return ret;
	}

	wd_release_queue(&q);
	wd_blkpool_destroy(pool);
	return 0;
}

static void *_dh_async_poll_test_thread(void *data)
{
	struct test_hpre_pthread_dt *pdata = data;
	struct wd_queue *q = pdata->q;
	int ret, cpuid;
	int pid = getpid();
	cpu_set_t mask;
	int thread_id = (int)syscall(__NR_gettid);

	CPU_ZERO(&mask);
	cpuid = pdata->cpu_id;
	CPU_SET(cpuid, &mask);
	if (cpuid) {
		ret = pthread_setaffinity_np(pthread_self(), sizeof(mask), &mask);
		if (ret < 0) {
			HPRE_TST_PRT("Proc-%d, thrd-%d:set affinity fail!\n",
						 pid, thread_id);
			return NULL;
		}
		HPRE_TST_PRT("Proc-%d, poll thrd-%d bind to cpu-%d!\n",
					 pid, thread_id, cpuid);
	}

	while (1) {
		ret = wcrypto_dh_poll(q, 1);
		if (ret < 0) {
			break;
		}

		if (asyn_thread_exit)
			break;
	}

	HPRE_TST_PRT("%s exit!\n", __func__);
	return NULL;
}

static int dh_async_test(int thread_num, __u64 lcore_mask,
			 __u64 hcore_mask, enum alg_op_type op_type)
{
	void *bufPool;
	struct wd_blkpool_setup setup;
	int i, ret, cnt = 0;
	int block_num = 1024;
	struct wd_queue *q;
	int h_cpuid;

	q = malloc(sizeof(struct wd_queue));
	if (!q) {
		HPRE_TST_PRT("malloc q memory fail!\n");
		return -ENOMEM;
	}
	memset(q, 0, sizeof(struct wd_queue));

	q->capa.alg = "dh";
	ret = wd_request_queue(q);
	if (ret) {
		HPRE_TST_PRT("request queue fail!\n");
		return ret;
	}
	memset(&setup, 0, sizeof(setup));
	setup.block_size = key_bits >> 2; // block_size;
	setup.block_num = block_num;
	setup.align_size = 64;

	bufPool = wd_blkpool_create(q, &setup);
	if (!bufPool) {
		HPRE_TST_PRT("%s(): create pool fail!\n", __func__);
		return -ENOMEM;
	}
		
	if (_get_one_bits(lcore_mask) > 0)
		cnt =  _get_one_bits(lcore_mask);
	else if (_get_one_bits(lcore_mask) == 0 &&
		 _get_one_bits(hcore_mask) == 0)
		cnt = thread_num;

	/* Create poll thread at first */
	test_thrds_data[0].pool = bufPool;
	test_thrds_data[0].q = q;
	test_thrds_data[0].thread_num = 1;
	test_thrds_data[0].op_type = op_type;
	test_thrds_data[0].cpu_id = 0;
	ret = pthread_create(&system_test_thrds[0], NULL,
			     _dh_async_poll_test_thread, &test_thrds_data[0]);
	if (ret) {
		HPRE_TST_PRT("Create poll thread fail!\n");
		return ret;
	}

	for (i = 1; i <= cnt; i++) {
		test_thrds_data[i].pool = bufPool;
		test_thrds_data[i].q = q;
		test_thrds_data[i].thread_num = thread_num;
		test_thrds_data[i].op_type = op_type;
		test_thrds_data[i].cpu_id = _get_cpu_id(i - 1, lcore_mask);
		gettimeofday(&test_thrds_data[i].start_tval, NULL);
		ret = pthread_create(&system_test_thrds[i], NULL,
				    _hpre_dh_sys_test_thread, &test_thrds_data[i]);
		if (ret) {
			HPRE_TST_PRT("Create %dth thread fail!\n", i);
			return ret;
		}
	}

	for (i = 1; i <= thread_num - cnt; i++) {
		h_cpuid = _get_cpu_id(i - 1, hcore_mask);
		if (h_cpuid > 0)
			h_cpuid += 64;

		test_thrds_data[i + cnt].pool = bufPool;
		test_thrds_data[i + cnt].q = q;
		test_thrds_data[i + cnt].thread_num = thread_num;
		test_thrds_data[i + cnt].op_type = op_type;
		test_thrds_data[i + cnt].cpu_id = h_cpuid;
		gettimeofday(&test_thrds_data[i + cnt].start_tval, NULL);
		ret = pthread_create(&system_test_thrds[i + cnt], NULL,
				 _hpre_dh_sys_test_thread, &test_thrds_data[i + cnt]);
		if (ret) {
			HPRE_TST_PRT("Create %dth thread fail!\n", i);
			return ret;
		}
	}

	for (i = 1; i <= thread_num; i++) {
		ret = pthread_join(system_test_thrds[i], NULL);
		if (ret) {
			HPRE_TST_PRT("Join %dth thread fail!\n", i);
			return ret;
		}
	}

	asyn_thread_exit = 1;

	ret = pthread_join(system_test_thrds[0], NULL);
	if (ret) {
		HPRE_TST_PRT("Join %dth thread fail!\n", i);
		return ret;
	}

	return 0;
}

void *_hpre_sys_test_thread(void *data)
{
	enum alg_op_type op_type;
	struct test_hpre_pthread_dt *pdata = data;
	
	op_type = pdata->op_type;
	if (op_type > MAX_RSA_ASYNC_TYPE && op_type < MAX_DH_TYPE ) {
		return _hpre_dh_sys_test_thread(data);
	} else {
		return _hpre_rsa_sys_test_thread(data);
	}
}

int main(int argc, char *argv[])
{
	void *pool = NULL;
	enum alg_op_type alg_op_type = HPRE_ALG_INVLD_TYPE;
	enum alg_op_mode mode;
	__u8 *in = NULL, *tp_in, *temp_in = NULL;
	__u8 *out = NULL;
	__u8 *key = NULL;
	char *in_file = NULL;
	char *out_file = NULL;
	char *key_file = NULL;
	int ret = 0, in_size = 0, op_size;
	int priv_key_size, pub_key_size, key_info_size;
	int read_size, out_fd = -1, try_close = 1;
	int block_num = 1024;
	struct wd_queue q;
	struct wcrypto_rsa_ctx_setup setup;
	struct wcrypto_dh_ctx_setup dh_setup;
	void *ctx = NULL;
	int thread_num, bits;
	__u64 core_mask[2];
	u32 value = 0;

	if (!argv[1] || !argv[6]) {
		HPRE_TST_PRT("pls use ./test_hisi_hpre -help get details!\n");
		return -EINVAL;
	}

	if (argv[7] && !strcmp(argv[7], "-check"))
		openssl_check = 1;
	if (argv[7] && !strcmp(argv[7], "-soft"))
		only_soft = 1;

	if (!strcmp(argv[1], "-system-qt")) {
		is_system_test = 1;
		HPRE_TST_PRT("Now doing system queue mng test!\n");
	} else if (!strcmp(argv[1], "-system-gen")) {
		alg_op_type = RSA_KEY_GEN;
		is_system_test = 1;
		HPRE_TST_PRT("Now doing system key gen test!\n");
	} else if (!strcmp(argv[1], "-system-vrf")) {
		alg_op_type = RSA_PUB_EN;
		is_system_test = 1;
		HPRE_TST_PRT("Now doing system verify test!\n");
	} else if (!strcmp(argv[1], "-system-sgn")) {
		alg_op_type = RSA_PRV_DE;
		is_system_test = 1;
		HPRE_TST_PRT("Now doing system sign test!\n");
	} else if (!strcmp(argv[1], "-system-asgn")) {
		alg_op_type = RSA_ASYNC_DE;
		is_system_test = 1;
		HPRE_TST_PRT("Now doing system rsa async sign test!\n");
	} else if (!strcmp(argv[1], "-system-avrf")) {
		alg_op_type = RSA_ASYNC_EN;
		is_system_test = 1;
		HPRE_TST_PRT("Now doing system rsa async verify test!\n");
	} else if (!strcmp(argv[1], "-system-agen")) {
		alg_op_type = RSA_ASYNC_GEN;
		is_system_test = 1;
		HPRE_TST_PRT("Now doing system rsa async kgerate test!\n");
	} else if (!strcmp(argv[1], "-system-gen1")) {
		HPRE_TST_PRT("DH key generation\n");
		alg_op_type = DH_GEN;
		is_system_test = 1;
	} else if (!strcmp(argv[1], "-system-agen1")) {
		HPRE_TST_PRT("DH gen async\n");
		alg_op_type = DH_ASYNC_GEN;
		is_system_test = 1;
	} else if (!strcmp(argv[1], "-system-gen2")) {
		HPRE_TST_PRT("DH key generation\n");
		alg_op_type = DH_COMPUTE;
		is_system_test = 1;
	} else if (!strcmp(argv[1], "-system-agen2")) {
		HPRE_TST_PRT("DH gen async\n");
		alg_op_type = DH_ASYNC_COMPUTE;
		is_system_test = 1;
	} else {
		goto basic_function_test;
	}

	if (argv[8]) {
		key_bits = strtoul(argv[8], NULL, 10);
	} else {
		key_bits = 2048;
	}

	/* Do sys test for performance and mult threads/process scenarioes */
	if (is_system_test) {
		if (!strcmp(argv[2], "-t")) {
			thread_num = strtoul((char *)argv[3], NULL, 10);
			if (thread_num <= 0 || thread_num > TEST_MAX_THRD) {
				HPRE_TST_PRT("Invalid threads num:%d!\n",
							 thread_num);
				HPRE_TST_PRT("Now set threads num as 2\n");
				thread_num = 2;
			}
		} else {
			HPRE_TST_PRT("./test_hisi_hpre --help get details\n");
			return -EINVAL;
		}
		if (strcmp(argv[4], "-c")) {
			HPRE_TST_PRT("./test_hisi_hpre --help get details\n");
			return -EINVAL;
		}

		if (argv[5][0] != '0' || argv[5][1] != 'x') {
			HPRE_TST_PRT("Err:coremask should be hex!\n");
			return -EINVAL;
		}
		if (strlen(argv[5]) > 34) {
			HPRE_TST_PRT("Warning: coremask is cut!\n");
			argv[5][34] = 0;
		}
		if (strlen(argv[5]) <= 18) {
			core_mask[0] = strtoull(argv[5], NULL, 16);
			if (core_mask[0] & 0x1) {
				HPRE_TST_PRT("Warn:cannot bind to core 0,\n");
				HPRE_TST_PRT("now run without binding\n");
				core_mask[0] = 0x0; /* no binding */
			}
			core_mask[1] = 0;
		} else {
			int offset = 0;
			char *temp;

			offset = strlen(argv[5]) - 16;
			core_mask[0] = strtoull(&argv[5][offset], NULL, 16);
			if (core_mask[0] & 0x1) {
				HPRE_TST_PRT("Warn:cannot bind to core 0,\n");
				HPRE_TST_PRT("now run without binding\n");
				core_mask[0] = 0x0; /* no binding */
			}
			temp = malloc(64);
			strcpy(temp, argv[5]);
			temp[offset] = 0;
			core_mask[1] = strtoull(temp, NULL, 16);
		}
		bits = _get_one_bits(core_mask[0]);
		bits += _get_one_bits(core_mask[1]);
		if (thread_num > bits) {
			HPRE_TST_PRT("Coremask not covers all thrds,\n");
			HPRE_TST_PRT("Bind first %d thrds!\n", bits);
		} else if (thread_num < bits) {
			HPRE_TST_PRT("Coremask overflow,\n");
			HPRE_TST_PRT("Just try to bind all thrds!\n");
		}
		if (!strcmp(argv[6], "-log")) {
			with_log = 1;
			performance_test = 0;
		} else if (!strcmp(argv[6], "-performance")) {
			with_log = 0;
			openssl_check = 0;
			performance_test = 1;
		} else {
			with_log = 0;
			performance_test = 0;
		}

		if (argv[9]) {
			ctx_num_per_q = strtoul(argv[9], NULL, 10);
			if (ctx_num_per_q <= 0) {
				HPRE_TST_PRT("Invalid ctx num per queue:%s!\n",
					     argv[9]);
				HPRE_TST_PRT("Now ctx num per queue is set as 1!\n");
				ctx_num_per_q = 1;
			}
		} else {
			HPRE_TST_PRT("Now  ctx num per queue is set as 1!\n");
			ctx_num_per_q = 1;
		}

		q_num = (thread_num - 1) / ctx_num_per_q + 1;

		if (argc == 13) {
			if (!strcmp(argv[10], "-g2")) {
				g_mode = "-g2";
			} else if (!strcmp(argv[10], "-com")) {
				g_mode = "-com";
			} else if (!strcmp(argv[10], "-crt")) {
				g_mode = "-crt";
			} else {
				HPRE_TST_PRT("pls use ./test_hisi_hpre -help get details!\n");
				return -EINVAL;
			}

			if (!strcmp(argv[11], "-seconds") || 
				!strcmp(argv[11], "-cycles")) {
				value = strtoul(argv[12], NULL, 10);
			}

			if (!strcmp(argv[11], "-seconds")) {
				t_seconds = value;
			} else if (!strcmp(argv[11], "-cycles")) {
				t_times = value;
			} else {
				HPRE_TST_PRT("pls use ./test_hisi_hpre -help get details!\n");
				return -EINVAL;
			}
		}

		if (argc == 12) {
			if (!strcmp(argv[10], "-seconds") || 
				!strcmp(argv[10], "-cycles")) {
				value = strtoul(argv[11], NULL, 10);
			}

			if (!strcmp(argv[10], "-seconds")) {
				t_seconds = value;
			} else if (!strcmp(argv[10], "-cycles")) {
				t_times = value;
			} else {
				HPRE_TST_PRT("pls use ./test_hisi_hpre -help get details!\n");
				return -EINVAL;
			}
		}

		if (argc == 11) {
			if (!strcmp(argv[10], "-g2")) {
				g_mode = "-g2";
			} else if (!strcmp(argv[10], "-com")) {
				g_mode = "-com";
			} else if (!strcmp(argv[10], "-crt")) {
				g_mode = "-crt";
			} else {
				HPRE_TST_PRT("pls use ./test_hisi_hpre -help get details!\n");
				return -EINVAL;
			}
		}

		HPRE_TST_PRT("Proc-%d: starts %d threads bind to %s\n",
					 getpid(), thread_num, argv[5]);
		HPRE_TST_PRT(" lcoremask=0x%llx, hcoremask=0x%llx\n",
					 core_mask[0], core_mask[1]);
		if (alg_op_type < MAX_RSA_SYNC_TYPE || alg_op_type == DH_GEN || alg_op_type == DH_COMPUTE)
			return hpre_sys_test(thread_num, core_mask[0],
					     core_mask[1], alg_op_type);
		else if (alg_op_type > MAX_RSA_SYNC_TYPE && alg_op_type < MAX_RSA_ASYNC_TYPE)
			return rsa_async_test(thread_num, core_mask[0],
					      core_mask[1], alg_op_type);
		else if (alg_op_type == DH_ASYNC_GEN || alg_op_type == DH_ASYNC_COMPUTE)
			return dh_async_test(thread_num, core_mask[0],
					      core_mask[1], alg_op_type);
		else
			return -1; /* to extend other test samples */
	}
basic_function_test:
	if (!strcmp(argv[1], "-en")) {
		alg_op_type = RSA_PUB_EN;
		HPRE_TST_PRT("RSA public key encrypto\n");
	} else if (!strcmp(argv[1], "-de")) {
		alg_op_type = RSA_PRV_DE;
		HPRE_TST_PRT("RSA private key decrypto\n");
	} else if (!strcmp(argv[1], "-gen")) {
		HPRE_TST_PRT("RSA key generation\n");
		alg_op_type = RSA_KEY_GEN;
	} else if (!strcmp(argv[1], "-gen1")) {
		HPRE_TST_PRT("DH key generation\n");
		alg_op_type = DH_GEN;
	} else if (!strcmp(argv[1], "-rsa-num")) {
		printf("num %d\n", wd_get_available_dev_num("rsa"));
		return 0;
	} else if (!strcmp(argv[1], "-dh-num")) {
		printf("num %d\n", wd_get_available_dev_num("dh"));
		return 0;
	} else if (!strcmp(argv[1], "-zip-num")) {
		printf("num %d\n", wd_get_available_dev_num("zip"));
		return 0;
	} else if (!strcmp(argv[1], "-xx-num")) {
		printf("num %d\n", wd_get_available_dev_num("xx"));
		return 0;
	} else if (!strcmp(argv[1], "--help")) {
		HPRE_TST_PRT("[version]:1.0\n");
		HPRE_TST_PRT("NAME\n");
		HPRE_TST_PRT("    test_hisi_hpre: test wd hpre function,etc\n");
		HPRE_TST_PRT("        example 1: test_hisi_hpre_rsa -system-asgn -t 1 -c 0x2 -performance -nocheck 2048 2\n");
		HPRE_TST_PRT("        example 2: test_hisi_hpre -gen1 256 -g2 public private crt_private -check hisi_hpre-0\n");
		HPRE_TST_PRT("SYNOPSIS\n");
		HPRE_TST_PRT("    test_hisi_hpre [op_type] -t [thread_num] -c [core_mask] [log] [openssl_check] [key_bits]...[ctx_num_per_q] [mode] [others]\n");
		HPRE_TST_PRT("    test_hisi_hpre [op_type] [key_bits] [mode] [in] [out] [key_file] [openssl_check] [dev_path]...[others]\n");
		HPRE_TST_PRT("DESCRIPTION\n");
		HPRE_TST_PRT("    [op_type]:\n");
		HPRE_TST_PRT("        -system-qt  = queue request and release test\n");
		HPRE_TST_PRT("        -system-gen  = RSA key generate synchronize test\n");
		HPRE_TST_PRT("        -system-agen  = RSA key generate c test\n");
		HPRE_TST_PRT("        -system-sgn  = RSA signature synchronize test\n");
		HPRE_TST_PRT("        -system-asgn  = RSA signature asynchronize test\n");
		HPRE_TST_PRT("        -system-vrf  = RSA verification synchronize test\n");
		HPRE_TST_PRT("        -system-avrf  = RSA verification asynchronize test\n");
		HPRE_TST_PRT("        -system-gen1  = DH phase 1 key generate synchronize test\n");
		HPRE_TST_PRT("        -system-agen1  = DH phase 1 key generate asynchronize test\n");
		HPRE_TST_PRT("        -system-gen2  = DH phase 2 key generate synchronize test\n");
		HPRE_TST_PRT("        -system-agen2  = DH phase 2 key generate asynchronize test\n");
		HPRE_TST_PRT("        -gen1  = DH share key generate test\n");
		HPRE_TST_PRT("    [thread_num]: start thread total\n");
		HPRE_TST_PRT("    [core_mask]: mask for bind cpu core, as 0x3 bind to cpu-1 and cpu-2\n");
		HPRE_TST_PRT("    [log]:\n");
		HPRE_TST_PRT("        -log\n");
		HPRE_TST_PRT("        -nolog\n");
		HPRE_TST_PRT("        -performance: use test DH and RSA perf\n");
		HPRE_TST_PRT("    [openssl_check]:\n");
		HPRE_TST_PRT("        1: check result compared with openssl\n");
		HPRE_TST_PRT("        0: no check\n");
		HPRE_TST_PRT("    [key_bits]:key size (bits)\n");
		HPRE_TST_PRT("    [ctx_num_per_q]:run ctx number per queue\n");
		HPRE_TST_PRT("    [mode]:\n");
		HPRE_TST_PRT("        -g2  = DH G2 mode\n");
		HPRE_TST_PRT("        -com  = common mode\n");
		HPRE_TST_PRT("        -crt  = RSA CRT mode\n");
		HPRE_TST_PRT("    [dev_path]: designed dev path\n");
		HPRE_TST_PRT("    [others]:\n");
		HPRE_TST_PRT("        -seconds [10] = test time set (s), for 10s\n");
		HPRE_TST_PRT("        -cycles [10]  = test cycle set (times), for 10 times\n");
		HPRE_TST_PRT("    [--help]  = usage\n");
		return 0;
	} else {
		HPRE_TST_PRT("Unknown option\n");
		HPRE_TST_PRT("<<use ./test_hisi_hpre --help get details>>\n");
		return -EINVAL;
	}
	if (argv[2]) {
		key_bits = strtoul(argv[2], NULL, 10);
		if (key_bits != 1024 && key_bits != 2048 &&
		    key_bits != 3072 && key_bits != 4096) {
			key_bits = 2048;
		}
	} else {
		key_bits = 2048;
	}
	HPRE_TST_PRT("RSA/DH key size=%d bits\n", key_bits);
	if (!strcmp(argv[3], "-crt")) {
		HPRE_TST_PRT("RSA CRT mode\n");
		mode = RSA_CRT_MD;
	} else if (!strcmp(argv[3], "-com") && alg_op_type < MAX_RSA_ASYNC_TYPE) {
		HPRE_TST_PRT("RSA Common mode\n");
		mode = RSA_COM_MD;
	} else if (!strcmp(argv[3], "-com") && alg_op_type > MAX_RSA_ASYNC_TYPE) {
		HPRE_TST_PRT("DH Common mode\n");
		mode = DH_COM_MD;
	} else if (!strcmp(argv[3], "-g2")) {
		HPRE_TST_PRT("DH g2 mode\n");
		mode = DH_G2;
	} else {
		HPRE_TST_PRT("please input a mode:<-crt> <-com>for rsa!\n");
		HPRE_TST_PRT("and:<-g2> <-com>for dh!\n");
		return -EINVAL;
	}
	in_file = argv[4];
	out_file = argv[5];
	key_file = argv[6];
	memset((void *)&q, 0, sizeof(q));
	if (argc >= 9) {
		strncpy(q.dev_path, argv[8], sizeof(q.dev_path));
		HPRE_TST_PRT("denote dev path:%s\n", argv[8]);
	}

	if (alg_op_type < MAX_RSA_ASYNC_TYPE && alg_op_type > HPRE_ALG_INVLD_TYPE) {
		q.capa.alg = "rsa";
	} else if (alg_op_type < MAX_DH_TYPE &&
		alg_op_type > MAX_RSA_ASYNC_TYPE) {
		q.capa.alg = "dh";
	} else {
		HPRE_TST_PRT("op type err!\n");
		return -EINVAL;
	}
	ret = wd_request_queue(&q);
	if (ret) {
		HPRE_TST_PRT("request queue fail!\n");
		return ret;
	}
	HPRE_TST_PRT("Get a WD HPRE queue of %s successfully!\n", q.capa.alg);
	memset(&dh_setup, 0, sizeof(dh_setup));
	memset(&setup, 0, sizeof(setup));
	if (alg_op_type < MAX_RSA_ASYNC_TYPE && mode == RSA_CRT_MD) {
		setup.is_crt = 1;
	} else if (alg_op_type < MAX_RSA_ASYNC_TYPE && mode == RSA_COM_MD) {
		setup.is_crt = 0;
	} else if (alg_op_type > MAX_RSA_ASYNC_TYPE &&
			   alg_op_type < HPRE_MAX_OP_TYPE && mode == DH_COM_MD) {
		dh_setup.is_g2 = 0;
	} else if (alg_op_type > MAX_RSA_ASYNC_TYPE &&
			   alg_op_type < HPRE_MAX_OP_TYPE && mode == DH_G2) {
		dh_setup.is_g2 = 1;
	} else {
		HPRE_TST_PRT("op type or mode err!\n");
		ret = -ENOMEM;
		goto release_q;
	}

	struct wd_blkpool_setup wsetup;
	memset(&wsetup, 0, sizeof(wsetup));
	if (!strncmp(q.capa.alg, "rsa", 3))
		wsetup.block_size = (key_bits >> 4) * 7;
	else if (!strncmp(q.capa.alg, "dh", 2))
		wsetup.block_size = key_bits >> 2;
	wsetup.block_num = block_num;
	wsetup.align_size = 64;

	pool = wd_blkpool_create(&q, &wsetup);
	if (!pool) {
		HPRE_TST_PRT("%s(): create ctx pool fail!\n", __func__);
		return -EINVAL;
	}
	
	if (!strncmp(q.capa.alg, "rsa", 3)) {
		setup.key_bits = key_bits;

		setup.br.alloc = (void *)wd_alloc_blk;
		setup.br.free = (void *)wd_free_blk;
		setup.br.iova_map = (void *)wd_blk_iova_map;
		setup.br.iova_unmap = (void *)wd_blk_iova_unmap;
		setup.br.usr = pool;
		ctx = wcrypto_create_rsa_ctx(&q, &setup);
		if (!ctx) {
			ret = -ENOMEM;
			HPRE_TST_PRT("create rsa ctx fail!\n");
			goto release_q;
		}
	} else if (!strncmp(q.capa.alg, "dh", 2)) {
		dh_setup.key_bits = key_bits;

		dh_setup.br.alloc = (void *)wd_alloc_blk;
		dh_setup.br.free = (void *)wd_free_blk;
		dh_setup.br.iova_map = (void *)wd_blk_iova_map;
		dh_setup.br.iova_unmap = (void *)wd_blk_iova_unmap;
		dh_setup.br.usr = pool;
		ctx = wcrypto_create_dh_ctx(&q, &dh_setup);
		if (!ctx) {
			ret = -ENOMEM;
			HPRE_TST_PRT("create dh ctx fail!\n");
			goto release_q;
		}
	}
	if (alg_op_type == RSA_KEY_GEN) {
		/* As generate key, we take in_file for storing public key
		 * and out_file for storing private key.
		 */
#ifdef RSA_OP_DEBUG
		return  hpre_test_rsa_op(alg_op_type, ctx, (__u8 *)in_file,
					 key_bits >> 3, (__u8 *)out_file, (__u8 *)key_file);
#else
		HPRE_TST_PRT("hpre_test_rsa_op not supported currently!\n");
		return 0;
#endif
	} else if (alg_op_type == DH_GEN) {
		ret = hpre_dh_test(ctx, pool);
		wcrypto_del_dh_ctx(ctx);
		return ret;
	} else if (alg_op_type == RSA_PUB_EN && (mode == RSA_CRT_MD ||
		   mode == RSA_COM_MD)) {
		read_size = pub_key_size = key_bits >> 2;
	} else if (alg_op_type == RSA_PRV_DE && mode == RSA_CRT_MD) {
		read_size = priv_key_size = (key_bits >> 4)  * 5;
	} else if (alg_op_type == RSA_PRV_DE && mode == RSA_COM_MD) {
		read_size = priv_key_size = key_bits >> 2;
	} else {
		HPRE_TST_PRT("op=%d mode=%d CMD err!\n", alg_op_type, mode);
		ret = -EINVAL;
		goto release_q;
	}
	if (openssl_check && alg_op_type != RSA_PUB_EN)
		key_info_size = read_size + (key_bits >> 2);
	else
		key_info_size = read_size;

	/* while we check the hw result, we need more info such as n and e */
	key = malloc(key_info_size);
	if (!key) {
		HPRE_TST_PRT("malloc key fail!\n");
		ret = -ENOMEM;
		goto release_q;
	}
	ret = hpre_test_read_from_file(key, key_file, key_info_size);
	if (ret < 0 || key_info_size != ret) {
		HPRE_TST_PRT("Fail to get key from %s!\n", key_file);
		HPRE_TST_PRT("Please input right RSA key!\n");
		goto release_q;
	}

	/* Try to get the input file size */
	read_size = hpre_test_get_file_size(in_file);
	if (read_size <= 0) {
		HPRE_TST_PRT("%s file is not valid!\n", in_file);
		goto release_q;
	}

	in = malloc(read_size + (key_bits >> 3));
	if (!in) {
		HPRE_TST_PRT("Fail to malloc mem for %s!\n", in_file);
		goto release_q;
	}
	memset(in, 0, read_size + (key_bits >> 3));
	ret = hpre_test_read_from_file(in, in_file, read_size);
	if (ret != read_size) {
		HPRE_TST_PRT("Fail to get data from %s!\n", in_file);
		goto release_q;
	}
	out = malloc(key_bits >> 3);
	if (!out) {
		HPRE_TST_PRT("Fail to malloc mem for output!\n");
		goto release_q;
	}
	memset(out, 0, key_bits >> 3);

	/* Initiated input Size */
	if (alg_op_type == RSA_PRV_DE) {
		in_size = key_bits >> 3;
	} else {
		in_size = (key_bits >> 3) - HPRE_PADDING_SZ;
		temp_in = malloc(key_bits >> 3);
		if (!temp_in) {
			HPRE_TST_PRT("Fail to malloc mem for temp in!\n");
			goto release_q;
		}
		memset(temp_in, 0, key_bits >> 3);
	}
	tp_in = in;
	do {
		/* While read_size is small the key size, it is finished */
		if (read_size - in_size > 0) {
			op_size = in_size;
			try_close = 0;
		} else {
			op_size = read_size;
			try_close = 1;
		}
#ifdef RSA_OP_DEBUG
		if (alg_op_type == RSA_PUB_EN) {
			memcpy(temp_in, tp_in, op_size);
			ret = hpre_test_rsa_op(alg_op_type, ctx, temp_in, op_size, out, key);
		} else {
			ret = hpre_test_rsa_op(alg_op_type, ctx, tp_in, op_size, out, key);
		}
#endif
		if (ret < 0) {
			HPRE_TST_PRT("HPRE operates failing!\n");
			goto release_q;
		}

		ret = hpre_test_write_to_file(out, ret, out_file,
									  out_fd, try_close);
		if (ret < 0) {
			HPRE_TST_PRT("Fail to write output buffer to %s!\n",
						 out_file);
			goto release_q;
		}
		if (key) {
			free(key);
			key = NULL;
		}
		if (try_close && openssl_check) {
			if (alg_op_type == RSA_PUB_EN)
				HPRE_TST_PRT("HPRE pub encrypt"\
				" %s to %s success!\n", in_file, out_file);
			else
				HPRE_TST_PRT("HPRE priv decrypt"\
				" %s to %s success!\n", in_file, out_file);
		} else if (try_close) {
			if (alg_op_type == RSA_PUB_EN)
				HPRE_TST_PRT("HPRE pub encrypt"\
				" %s to %s finished!\n", in_file, out_file);
			else
				HPRE_TST_PRT("HPRE priv decrypt"\
				" %s to %s finished!\n", in_file, out_file);
		}
		out_fd = ret;
		tp_in += op_size;
		read_size -= op_size;
	} while (!try_close);
release_q:
	if (in)
		free(in);
	if (out)
		free(out);
	if (key)
		free(key);
	if (temp_in)
		free(temp_in);
	if (hpre_test_rsa)
		RSA_free(hpre_test_rsa);
	wcrypto_del_rsa_ctx(ctx);
	wd_blkpool_destroy(pool);
	wd_release_queue(&q);

	return ret;
}
